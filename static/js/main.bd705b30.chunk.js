(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{28:function(e,t,n){e.exports=n.p+"static/media/install.2fd58801.gif"},29:function(e,t,n){e.exports=n.p+"static/media/next-steps.5a84bcf8.gif"},32:function(e,t,n){e.exports=n(53)},39:function(e,t,n){},53:function(e,t,n){"use strict";n.r(t);var a=n(1),l=n.n(a),r=n(12),o=n.n(r),i=n(56),s=(n(37),n(4)),c=n(8),m=n(6),u=n(5),h=n(7),d=(n(39),n(3)),p=n(25),f=n.n(p),g=n(26),y=n.n(g),E=(n(49),n(50),function(e){function t(){var e;Object(s.a)(this,t);var n=(e=Object(m.a)(this,Object(u.a)(t).call(this))).createKeywordMapper({"support.function":"avg",keyword:"case|def|else|enum|if|lat|let|match|rel|select|spawn|with","constant.language":"true|false|Nil","storage.type":"Bool|Int|Str|Option|Result|List"},"identifier",!0);return e.$rules={start:[{token:"comment",regex:"\\/\\/.*$"},{token:"comment",start:"/\\*",end:"\\*/"},{token:"string",regex:'".*?"'},{token:"string",regex:"'.*?'"},{token:"string",regex:"`.*?`"},{token:"constant.numeric",regex:"[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"},{token:n,regex:"[a-zA-Z_$][a-zA-Z0-9_$]*\\b"},{token:"keyword.operator",regex:"\\+|\\-|\\/|\\/\\/|%|<@>|@>|<@|&|\\^|~|<|>|<=|=>|==|!=|<>|="},{token:"paren.lparen",regex:"[\\(]"},{token:"paren.rparen",regex:"[\\)]"},{token:"text",regex:"\\s+"}]},e.normalizeRules(),e}return Object(h.a)(t,e),t}(window.ace.acequire("ace/mode/text_highlight_rules").TextHighlightRules)),b=function(e){function t(){var e;return Object(s.a)(this,t),(e=Object(m.a)(this,Object(u.a)(t).call(this))).HighlightRules=E,e}return Object(h.a)(t,e),t}(window.ace.acequire("ace/mode/java").Mode),x=(n(51),function(e){function t(e){var n;return Object(s.a)(this,t),(n=Object(m.a)(this,Object(u.a)(t).call(this,e))).run=function(){n.setState({waiting:!0},function(){var e=n.state.input;n.props.flix.run(e,function(e){return n.setState({waiting:!1,output:e})})})},n.onChange=function(e){n.setState({input:e})},n.onRunClick=function(){n.run()},n.onResetClick=function(){n.setState(n.getInitialState())},n.resultBox=function(){return n.state.output?"success"===n.state.output.status?l.a.createElement(d.d,{body:!0,outline:!0,color:"success",className:"mt-2"},l.a.createElement(d.h,null,"Main returned: ",l.a.createElement("code",null,n.state.output.result))):l.a.createElement(d.d,{body:!0,outline:!0,color:"danger",className:"mt-2"},l.a.createElement(d.h,null,l.a.createElement("code",null,f()(n.state.output.message)))):void 0},n.state=n.getInitialState(),n}return Object(h.a)(t,e),Object(c.a)(t,[{key:"getInitialState",value:function(){return{input:this.props.code,output:void 0,waiting:!1}}},{key:"componentDidMount",value:function(){var e=new b;this.refs.aceEditor.editor.getSession().setMode(e)}},{key:"render",value:function(){return l.a.createElement("div",null,l.a.createElement("div",null,l.a.createElement("div",null,l.a.createElement(y.a,{mode:"text",theme:"chrome",ref:"aceEditor",showGutter:!1,showPrintMargin:!1,highlightActiveLine:!1,onChange:this.onChange,value:this.state.input,autoScrollEditorIntoView:!0,minLines:23,maxLines:23,editorProps:{$blockScrolling:!0}}),this.state.waiting),l.a.createElement(d.c,null,l.a.createElement(d.b,{color:"primary",outline:!0,className:"btn-xs",onClick:this.onRunClick},"Run Main"),l.a.createElement(d.b,{color:"secondary",outline:!0,className:"btn-xs",onClick:this.onResetClick},"Reset"))),this.resultBox())}}]),t}(a.Component)),w=function(){return[{name:"Algebraic Data Types and Pattern Matching",code:"/// An algebraic data type for shapes.\nenum Shape {\n    case Circle(Int),        // circle radius\n    case Square(Int),        // side length\n    case Rectangle(Int, Int) // height and width\n}\n\n/// Computes the area of the given shape using \n/// pattern matching and basic arithmetic.\ndef area(s: Shape): Int = match s with {\n    case Circle(r)       => 3 * (r * r)\n    case Square(w)       => w * w\n    case Rectangle(h, w) => h * w\n}\n\n// Computes the area of a 2 by 4.\ndef main(): Int = area(Rectangle(2, 4))\n"},{name:"Lists and List Processing",code:"/// In Flix, as in many functional programming languages, \n/// lists are the bread and butter.\n\n/// We can easily construct a list:\ndef aList(): List[Int] = 1 :: 2 :: 3 :: Nil\n\n/// We can easily append two lists:\ndef bList(): List[Int] = aList() ::: aList()\n\n/// We can use pattern matching to take a list apart:\ndef length[a](l: List[a]): Int = match l with {\n  case Nil     => 0\n  case x :: xs => 1 + length(xs) \n}\n\n/// The Flix library has extensive support for lists:\ndef main(): Bool = \n    let l1 = List.range(0, 10);\n    let l2 = List.intersperse(42, l1);\n    let l3 = List.map(x -> x :: x :: Nil, l2);\n    let l4 = List.flatten(l3);\n    List.exists(x -> x == 0, l4)\n"},{name:"Higher-Order Functions",code:"/// Returns the sum of x and y.\ndef add(x: Int, y: Int): Int = x + y\n\n/// Returns x plus one.\ndef inc(x: Int): Int = add(x, 1)\n\n/// Returns a function that applies f twice.\ndef twice(f: Int -> Int): Int -> Int = x -> f(f(x))\n\n/// Returns x plus two.\ndef two(x: Int): Int = twice(inc)(x)\n\n/// Returns 123 plus 4 = 127.\ndef main(): Int = twice(two)(123)\n"},{name:"Enums and Parametric Polymorphism",code:"/// An algebraic data type for binary trees\n/// where each leaf carries a value of type a.\nenum Tree[a] {\n    case Leaf(a),\n    case Node(Tree[a], Tree[a])\n}\n\n/// A higher-order function that transforms a tree with\n/// elements of type a to a tree with elements of type b.\ndef map[a, b](f: a -> b, t: Tree[a]): Tree[b] = \n  match t with {\n    case Leaf(x)    => Leaf(f(x))\n    case Node(l, r) => Node(map(f, l), map(f, r))        \n  }\n\n/// Returns a simple tree with two leafs.\ndef tree(): Tree[Int] = Node(Leaf(1), Leaf(2))\n\n/// Squares all elements in the simple tree.\ndef main(): Tree[Int] = map(x -> x * x, tree())\n"},{name:"Function Composition, Pipelines, and Currying",code:"/// Flix supports function composition with\n/// the |> operator (among others) and currying.\n/// This makes it easy to construct pipelines:\n                \n/// Constructs a list with ten elements and performs\n/// various operations on it in a pipeline.\ndef main(): Bool = \n    List.range(0, 10) |>\n    List.map(x -> x * x) |>\n    List.take(5) |> \n    List.exists(x -> x == 1)\n"},{name:"Uniform Function Call Syntax (UFCS)",code:"/// Returns x plus one.\ndef inc(x: Int): Int = x + 1\n\n/// Returns the sum of x and y.\ndef sum(x: Int, y: Int): Int = x + y\n\n/// We can call these functions in the standard way:\ndef main(): Int = \n    let i = inc(123);\n    let s = sum(123, 456);\n        i + s\n\n/// Or with uniform function call syntax:\ndef main2(): Int = \n    let i = 123.inc();\n    let s = 123.sum(456);\n        i + s\n\n/// Or even using an infix notation for sum:\ndef main3(): Int = \n    let s = 123 `sum` 456;\n        s\n"},{name:"Mutual Recursion with Full Tail-Call Elimination",code:"/// Flix, despite being a JVM-language, \n/// supports full tail call elimination.\n\n/// We can demonstrate this with a naive implementation\n/// of a program that computes if a number is odd.\n\n/// Returns true if n is odd.\ndef isOdd(n: Int): Bool = \n    if (n == 0) false else isEvn(n - 1)\n\n/// Returns true if n is even.\ndef isEvn(n: Int): Bool = \n    if (n == 0) true else isOdd(n - 1)\n\n/// We can now compute if 12345 is odd.\n/// In a language without TCE this would\n/// quickly consume all stack space.\ndef main(): Bool = isOdd(12345)\n"},{name:"Sending and Receiving on Channels",code:"/// A function that sends every element of a list\ndef send(o: Channel[Int], l: List[Int]): Unit =\n    match l with {\n        case Nil     => ()\n        case x :: xs => o <- x; send(o, xs)\n    }\n\n/// A function that receives n elements \n/// and collects them into a list.\ndef recv(i: Channel[Int], n: Int): List[Int] =\n    match n with {\n        case 0 => Nil\n        case _ => (<- i) :: recv(i, n - 1)\n    }\n\n/// A function that calls receive and sends the result on d.\ndef wait(i: Channel[Int], n: Int, d: Channel[List[Int]]): Unit =\n    d <- recv(i, n);\n    ()\n\n/// Spawn a process for send and wait, and print the result.\ndef main(): List[Int] =\n    let l = 1 :: 2 :: 3 :: Nil;\n    let c = chan Int 100;\n    let d = chan List[Int] 100;\n    spawn send(c, l);\n    spawn wait(c, List.length(l), d);\n    <- d\n"},{name:"Using Channels and Select",code:' /// Mooo\'s `n` times on channel `c`.\ndef mooo(c: Channel[Str], n: Int): Unit = match n with {\n    case 0 => ()\n    case n => c <- "Mooo!"; mooo(c, n - 1)\n}\n\n/// Meow\'s `n` times on channel `c`.\ndef meow(c: Channel[Str], n: Int): Unit = match n with {\n    case 0 => ()\n    case n => c <- "Meow!"; meow(c, n - 1)\n}\n\n/// Hiss\'es `n` times on channel `c`.\ndef hiss(c: Channel[Str], n: Int): Unit = match n with {\n    case 0 => ()\n    case n => c <- "Hiss!"; hiss(c, n - 1)\n}\n\n/// Start the animal farm...\ndef main(): Str =\n    let c1 = chan Str 1;\n    let c2 = chan Str 1;\n    let c3 = chan Str 1;\n    spawn mooo(c1, 0);\n    spawn meow(c2, 3);\n    spawn hiss(c3, 7);\n    select {\n        case mooo <- c1 => mooo\n        case meow <- c2 => meow\n        case hiss <- c3 => hiss\n    }\n'},{name:"Fixpoint Computations with Top-Level Constraints",code:"/// We can use Flix as an ordinary Datalog solver.\n            \n/// Declare two predicate symbols.\nrel Edge(x: Int, y: Int)\nrel Path(x: Int, y: Int)\n\n/// Declare some edge facts.\nEdge(1, 2). \nEdge(2, 3).\nEdge(2, 4).\nEdge(3, 5).\n\n// Declare some constraints.\nPath(x, y) :- Edge(x, y).\nPath(x, z) :- Path(x, y), Edge(y, z).\n"},{name:"First-Class Constraints and Fixpoints",code:'/// Declare two predicate symbols.\nrel ParentOf(x: Str, y: Str)\nrel AncestorOf(x: Str, y: Str)\n\n/// Returns a collection of facts.\ndef getFacts(): Schema { ParentOf(Str, Str), AncestorOf(Str, Str) } = {\n    ParentOf("Pompey", "Strabo").\n    ParentOf("Gnaeus", "Pompey").\n    ParentOf("Pompeia", "Pompey").\n    ParentOf("Sextus", "Pompey").\n}\n\n/// Returns a collection of rules to compute ancestors.\ndef getRules(): Schema { ParentOf(Str, Str), AncestorOf(Str, Str) } = {\n    AncestorOf(x, y) : \u2212 ParentOf(x, y).\n    AncestorOf(x, z) : \u2212 AncestorOf(x, y), AncestorOf(y, z).\n}\n\n/// Composes the facts and rules, and computes the lfp.\ndef main(): Schema = { ParentOf(Str, Str), AncestorOf(Str, Str) } = \n    solve getFacts() <+> getRules()\n'},{name:"Pipelines of Fixpoint Computations",code:'// Declare three predicate symbols.\nrel ColorEdge(x: Int, c: Str, y: Int)\nrel ColorPath(x: Int, c: Str, y: Int)\nrel ColorlessPath(x: Int, y: Int)\n\ndef main(): Bool =\n    // Introduce some facts for colored paths.\n    let f1 = {\n        ColorEdge(1, "blue", 2).\n        ColorEdge(2, "blue", 3).\n    };\n    // Introduce some rules for computing paths.\n    let r1 = {\n        ColorPath(x, c, y) :- ColorEdge(x, c, y).\n        ColorPath(x, c, z) :- ColorPath(x, c, y), ColorEdge(y, c, z).\n    };\n    // Introduce some rules for computing colorless paths.\n    let r2 = {\n        ColorlessPath(x, y) :- ColorPath(x, _, y).\n    };\n    // Compute all the color paths.\n    let m1 = solve (f1 <+> r1);\n\n    // Use that result to compute colorless paths.\n    let m2 = solve (m1 <+> r2);\n\n    // Check that there is a path from 1 to 3.\n    m2 |= ColorlessPath(1, 3).\n'},{name:"An Interpreter for a Trivial Expression Language",code:"//\n// We define an adt to capture the syntax of arithmetic expressions.\n//\nenum AExp {\n    // a literal integer constant.\n    case Cst(Int),\n\n    // a binary addition expression: e1 + e2.\n    case Plus(AExp, AExp),\n\n    // a binary subtraction expression: e1 - e2.\n    case Minus(AExp, AExp),\n\n    // a binary multiplication expression: e1 * e2.\n    case Times(AExp, AExp),\n\n    // a binary division expression: e1 / e2.\n    case Divide(AExp, AExp),\n\n    //n a if-then-else expression: if (e1) e2 else e3.\n    case IfThenElse(BExp, AExp, AExp)\n}\n\n//\n// We then define an adt to capture the syntax of boolean expressions.\n//\nenum BExp {\n    // the true boolean literal.\n    case True,\n\n    // the false boolean literal.\n    case False,\n\n    // a logical negation expression: !e.\n    case Not(BExp),\n\n    // a logical conjunction expression: e1 && e2.\n    case Conj(BExp, BExp),\n\n    // a logical disjunction expression: e1 || e2.\n    case Disj(BExp, BExp),\n\n    // an equality of expression: e1 == e2.\n    case Eq(AExp, AExp),\n\n    // an inequality of expression: e1 != e2.\n    case Neq(AExp, AExp)\n}\n\n//\n// We now define a small interpreter for arithmetic expressions.\n//\ndef evalAExp(e: AExp): Int = match e with {\n    case Cst(i)                 => i\n    case Plus(e1, e2)           => evalAExp(e1) + evalAExp(e2)\n    case Minus(e1, e2)          => evalAExp(e1) - evalAExp(e2)\n    case Times(e1, e2)          => evalAExp(e1) * evalAExp(e2)\n    case Divide(e1, e2)         => evalAExp(e1) / evalAExp(e2)\n    case IfThenElse(e1, e2, e3) =>\n        let cond = evalBExp(e1);\n            if (cond) evalAExp(e2) else evalAExp(e3)\n}\n\n//\n// and here is the small interpreter for boolean expressions.\n//\ndef evalBExp(e: BExp): Bool = match e with {\n    case True           => true\n    case False          => false\n    case Not(e)         => !evalBExp(e)\n    case Conj(e1, e2)   => evalBExp(e1) && evalBExp(e2)\n    case Disj(e1, e2)   => evalBExp(e1) || evalBExp(e2)\n    case Eq(e1, e2)     => evalAExp(e1) == evalAExp(e2)\n    case Neq(e1,e2)     => evalAExp(e1) != evalAExp(e2)\n}\n\n\n// We can now run it!\ndef main(): Int = evalAExp(\n    IfThenElse(Neq(Cst(1), Cst(2)), Cst(42), Cst(21))\n)\n"}]},v=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="The Flix Programming Language"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{xs:"6"},l.a.createElement("h1",null,"The Flix Programming Language"),l.a.createElement("p",null,"Flix is a principled and opinionated functional programming language that takes inspiration from F#, Go, OCaml, Haskell, Rust, and Scala."),l.a.createElement("p",null,"Flix visually resembles Scala, but its type system is closer to that of OCaml and Haskell. Its concurrency model is inspired by Go-style processes and channels."),l.a.createElement("p",null,"Flix compiles to JVM bytecode and runs on the Java Virtual Machine. Flix supports full tail call elimination which means that tail calls (even to other functions) never overflow the stack."),l.a.createElement("p",null,"Flix performance is typically within 1-3x of equivalent Scala code."),l.a.createElement("p",null,"Research on Flix explores connections between functional and logic programming in the area of declarative fixpoint computations.")),l.a.createElement(d.j,{xs:"6"},l.a.createElement(k,{flix:this.props.flix}))),l.a.createElement("hr",{className:"mb-3"}),l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{md:"12"},l.a.createElement("h2",null,"Features at a Glance")),l.a.createElement(d.j,{md:"4",style:{fontSize:"1.2em"}},l.a.createElement("ul",null,l.a.createElement("li",null,"algebraic data types"),l.a.createElement("li",null,"pattern matching"),l.a.createElement("li",null,"first-class functions"),l.a.createElement("li",null,"parametric polymorphism"),l.a.createElement("li",null,"Hindley-Milner type inference"))),l.a.createElement(d.j,{md:"4",style:{fontSize:"1.2em"}},l.a.createElement("ul",null,l.a.createElement("li",null,"channel-based concurrency"),l.a.createElement("li",null,"first-class datalog constraints"),l.a.createElement("li",null,"unboxed primitives"),l.a.createElement("li",null,"namespaces"),l.a.createElement("li",null,"expressions holes"))),l.a.createElement(d.j,{md:"4",style:{fontSize:"1.2em"}},l.a.createElement("ul",null,l.a.createElement("li",null,"full tail call elimination"),l.a.createElement("li",null,"compilation to JVM bytecode"),l.a.createElement("li",null,"core standard library"),l.a.createElement("li",null,"human friendly errors"),l.a.createElement("li",null,"interactive mode")))),l.a.createElement("hr",{className:"mb-3"}),l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{xs:"6"},l.a.createElement("h3",null,"Recent News"),l.a.createElement("ul",null,[{name:"Flix version 0.4.0 released!",date:"2019-01-03"},{name:"The new Flix website is now online!",date:"2019-01-03"},{name:"Jonathan and Simon are working on Go-style processes and channels for Flix.",date:"2018-12-20"},{name:"The paper entitled: 'Implicit Parameters for Logic Programming' is now available.",date:"2018-09-03"}].map(function(e){return l.a.createElement("li",{key:e.name},e.date," - ",e.name,l.a.createElement("br",null))}))),l.a.createElement(d.j,{xs:"6"},l.a.createElement("h3",null,"Bread- and Butter Functional Programming"),l.a.createElement("p",null,"Flix supports the basic building blocks of typed functional programs: algebraic data types, pattern matching, and parametric polymorphism (generics). It uses a Hindley-Milner style type system which supports type inference within a function. Its syntax is inspired by Scala with an emphasis on the use of keywords."))),l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{xs:"6"},l.a.createElement("h3",null,"Process and Channel-based Concurrency"),l.a.createElement("p",null,"Flix embraces a Go-style concurrency model based on processes and channels. Processes communicate by sharing immutable messages which help prevent race conditions. The current implementation is based on threads, but when the JVM gains support for light-weight threads or continuations, we plan to switch to one of those.")),l.a.createElement(d.j,{xs:"6"},l.a.createElement("h3",null,"Principled Design"),"It is our goal to build Flix on a solid foundation of ideas from programming language research. In our design, we try to identify and guide ourselves by a collection of principles each with a well-documented rationale. We want Flix to adopt great ideas from languages such as F#, Go, OCaml, Haskell, Rust, and Scala.")),l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{xs:"6"},l.a.createElement("h3",null,"Planned Features"),l.a.createElement("p",null,"At the moment, Flix has the feature set of a ML-style language. We are actively working on adding support for two features essential to real-world programming: an abstraction mechanism based on ",l.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Type_class"},"type classes")," and an ",l.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Effect_system"},"effect system")," to allow safe interaction with the outside world.")),l.a.createElement(d.j,{xs:"6"},l.a.createElement("h3",null,"Research and Flix"),l.a.createElement("p",null,"Flix is also a research project which explores various aspects of programming language design. A large part of the research is on connections between functional and logic programming, specifically Datalog. Flix, as probably the only language in the world, supports first-class Datalog constraints enriched with lattice semantics."),l.a.createElement("p",null,"For more information, we refer to our research papers."))))}}]),t}(a.Component),k=function(e){function t(e){var n;Object(s.a)(this,t),n=Object(m.a)(this,Object(u.a)(t).call(this,e));var a,l=w(),r=(a=l.length,Math.floor(Math.random()*Math.floor(a)));return n.state={choice:r,samples:l},n}return Object(h.a)(t,e),Object(c.a)(t,[{key:"onChange",value:function(e){var t=e.target.value;this.setState({choice:t})}},{key:"getEditor",value:function(){var e=this.state.choice,t=this.state.samples[e];return l.a.createElement(x,{key:t.name,flix:this.props.flix,code:t.code,lines:18},t.code)}},{key:"isConnected",value:function(){return this.props.flix.connected?l.a.createElement(d.a,{color:"info",className:"float-right mt-1"},"Connected"):l.a.createElement(d.a,{color:"secondary",className:"float-right mt-1"},"Disconnected")}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement("select",{className:"mb-2",value:this.state.choice,onChange:this.onChange.bind(this)},this.state.samples.map(function(e,t){return l.a.createElement("option",{key:t,value:t},e.name)})),this.isConnected(),this.getEditor())}}]),t}(a.Component);var j=v,F=n(28),I=n.n(F),C=n(29),O=n.n(C),S=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="Flix | Getting Started"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement("h1",null,"Getting Started"),l.a.createElement("p",null,"Flix runs on any platform that supports the Java Virtual Machine. Installation is as easy as downloading and running a jar file."),l.a.createElement(d.p,{className:"mb-lg-5"},l.a.createElement(d.j,{md:"12"},l.a.createElement("h2",null,"Up and Running")),l.a.createElement(d.j,{md:"6"},l.a.createElement("ol",null,l.a.createElement("li",{className:"mb-2"},"Ensure that you have Java 11 or later installed. You can check your Java version with the command ",l.a.createElement("code",null,"java -version"),". You should see something like ",l.a.createElement("code",null,'openjdk version "11.0.1"'),"."),l.a.createElement("li",{className:"mb-2"},"Download ",l.a.createElement("a",{href:"https://github.com/flix/flix/releases"},"flix.jar")," from the GitHub releases page."),l.a.createElement("li",{className:"mb-2"},"Run the command ",l.a.createElement("code",null,"java -jar flix.jar --version")," to verify that you have the expected version of Flix."),l.a.createElement("li",{className:"mb-2"},"Run the command ",l.a.createElement("code",null,"java -jar flix.jar")," to start Flix in interactive mode with a read-eval-print loop."),l.a.createElement("li",{className:"mb-2"},"Enter any expression to have it evaluated, e.g. ",l.a.createElement("code",null,"21 + 42"),"."))),l.a.createElement(d.j,{md:"6"},l.a.createElement(d.d,{className:"p-2"},l.a.createElement(d.g,{top:!0,src:I.a})))),l.a.createElement(d.p,{className:"mb-lg-5"},l.a.createElement(d.j,{md:"12"},l.a.createElement("h2",null,"Next Steps: Using a File")),l.a.createElement(d.j,{md:"6"},l.a.createElement(d.d,{className:"p-2"},l.a.createElement(d.g,{top:!0,src:O.a}))),l.a.createElement(d.j,{md:"6"},l.a.createElement("ol",null,l.a.createElement("li",{className:"mb-2"},"Create the file ",l.a.createElement("code",null,"test.flix")," with the content:",l.a.createElement(d.d,null,l.a.createElement(d.e,null,l.a.createElement(d.h,null,l.a.createElement("code",null,"def main(): Unit = ()"))))),l.a.createElement("li",{className:"mb-2"},"Run the command ",l.a.createElement("code",null,"java -jar flix.jar test.flix --interactive")," to start Flix in interactive mode with the file loaded."),l.a.createElement("li",{className:"mb-2"},"Type ",l.a.createElement("code",null,"main()")," into the command prompt to run the main function."),l.a.createElement("li",{className:"mb-2"},"Type ",l.a.createElement("code",null,":w")," to watch the file for changes. You can now edit ",l.a.createElement("code",null,"test.flix")," as much as you want. Every time you save, Flix will automatically reload the file, and print any errors.")))))}}]),t}(a.Component),A=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="Flix | Principles"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement("h1",null,"Design Principles"),l.a.createElement("p",{className:"mb-3"},"We believe that the development of a programming language should follow a set of principles. That is, when a design decision is made there should exist some rationale for why that decision was made. By outlining these principles, as we develop Flix, we hope to keep ourselves honest and to communicate the kind of language Flix aspires to be."),l.a.createElement("p",{className:"mb-3"},"Many of these ideas and principles come from languages that have inspired Flix, including Ada, Elm, F#, Go, Haskell, OCaml, Rust, and Scala."),l.a.createElement(d.f,null,l.a.createElement(P,{name:"Simple is not easy"},"We believe in Rich Hickey's creed: ",l.a.createElement("a",{href:"https://www.infoq.com/presentations/Simple-Made-Easy"},"simple is not easy"),". We prefer a language that gets things right to one that makes things easy. Such a language might take longer to learn in the short run, but its simplicity pays off in the long run."),l.a.createElement(P,{name:"Everything is an expression"},"Flix is a functional language and embraces the idea that everything should be an expression. Flix has no local variable declarations or if-then-else statements, instead it has let-bindings and if-then-else expressions. However, Flix does not take this idea as far as the Scheme languages. Flix still has declarations, namespaces, and so forth that are not expressions."),l.a.createElement(P,{name:"Local type inference"},"The Flix type system is based on ",l.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"},"Hindley-Milner")," which supports full type inference. As a design choice, we require all functions to be annotated with their argument and return types. We believe that requiring type signatures has three distinct advantages that outweigh the disadvantages.",l.a.createElement("ol",null,l.a.createElement("li",null,"Type signatures are useful as documentation and to aid program understanding."),l.a.createElement("li",null,"Type signatures accurately assign blame for type errors."),l.a.createElement("li",null,"Type signatures enable parallel type checking.")),"Of these, we think the former two are significantly more important than the latter."),l.a.createElement(P,{name:"Uniform function call syntax"},"Flix supports ",l.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax"},"uniform function call syntax (UFCS)"),". In Flix, the syntax for function application is: ",l.a.createElement("code",null,"f(a, b, c)"),'. UFCS enables an "object-oriented" style where we can write the same function call as ',l.a.createElement("code",null,"a.f(b, c)"),". As another example, the function call ",l.a.createElement("code",null,"length(xs)")," can also be written as ",l.a.createElement("code",null,"xs.length()"),". UFCS is a purely syntactic mechanism and does not influence the semantics of a call."),l.a.createElement(P,{name:"Keyword-based syntax"},"The Flix syntax is inspired by Scala. We believe that short key words make it easy to visually identify the overall structure of a piece of code. Flix tries to use three letter keywords were appropriate: ",l.a.createElement("code",null,"def"),", ",l.a.createElement("code",null,"let"),", ",l.a.createElement("code",null,"law"),",",l.a.createElement("code",null,"rel"),", but not for commonly established concepts: ",l.a.createElement("code",null,"if ... else "),"and ",l.a.createElement("code",null,"match .... with"),"."),l.a.createElement(P,{name:"Consistent syntax"},"Flix aims to have consistent and predictable syntax. As an example, we try to have the syntax of types mirror that of expressions:",l.a.createElement("ul",null,l.a.createElement("li",null,"A function application is written as ",l.a.createElement("code",null,"f(a, b, c)")," whereas a type application is written as ",l.a.createElement("code",null,"f[a, b, c]"),"."),l.a.createElement("li",null,"A function expression is written as ",l.a.createElement("code",null,"x -> x + 1")," whereas a function type is written as ",l.a.createElement("code",null,"Int -> Int"),"."),l.a.createElement("li",null,"A tuple is written as ",l.a.createElement("code",null,"(true, 12345)")," whereas a tuple type is written as ",l.a.createElement("code",null,"(Bool, Int)"),"."))),l.a.createElement(P,{name:"Human-readable errors"},"In the spirit of ",l.a.createElement("a",{href:"https://elm-lang.org/blog/compilers-as-assistants"},"Elm")," and ",l.a.createElement("a",{href:"https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html"},"Rust"),", Flix aims to have human readable and understandable compiler messages. Messages should describe the problem in detail and provide information about the context, including suggestions for how to correct the problem."),l.a.createElement(P,{name:"Private by default"},"Flix embraces the principle of least privilege. In Flix, declarations are hidden by default (i.e. private) and cannot be accessed from outside of their namespace (or sub-namespaces). We believe it is important that programmers are forced to make a conscious choice about when to make a declaration publicly visible."),l.a.createElement(P,{name:"Closed world assumption"},"Flix requires all code to be available at compile-time. This enables a range of compilation techniques, such as:",l.a.createElement("ul",null,l.a.createElement("li",null,"Monomorphization to avoid unnecessary boxing of primitives."),l.a.createElement("li",null,'Aggressive dead code elimination ("tree shaking") to remove unused functions.'),l.a.createElement("li",null,"Inlining across namespaces."),l.a.createElement("li",null,"Whole-program analysis."))),l.a.createElement(P,{name:"Illegal states should be unrepresentable"},"We believe that a language should make it easy to make illegal states unrepresentable. For example, algebraic data types can be used to precisely define the possible values of a type. In Flix, in the future, we want to take this a step further, and allow refinement of some types. For example, to express that some value must not only be an integer, but also that it must fall within a range, e.g. ",l.a.createElement("code",null,"[0-99]"),".",l.a.createElement("br",null),l.a.createElement(d.a,null,"in progress")),l.a.createElement(P,{name:"Nothing is executed before main"},"In Flix, ",l.a.createElement("code",null,"main")," is the entry point of a program. No (user-defined) code is ever executed before ",l.a.createElement("code",null,"main"),". No static initializers, no static fields. No class loaders. Main is always first. This makes it easy to reason about startup behavior."),l.a.createElement(P,{name:"Small, but comprehensive standard library"},"Flix has a small standard library with a few common data types, e.g. ",l.a.createElement("code",null,"Option"),", ",l.a.createElement("code",null,"List"),", ",l.a.createElement("code",null,"Set"),", and ",l.a.createElement("code",null,"Map"),", but for these it offers a comprehensive collection of functionality. For example, the standard library has more than 65 functions for working with lists. We want the standard library to offer a common set of abstractions which are usable by most programs, but not much else."),l.a.createElement(P,{name:"Declare before use"},"In Flix things must be defined before they can be used. Algebraic data types, functions, local variables, and other programming elements must be declared before they can be used by other program parts. Declarations make it easy to assign blame; we assume declarations to be correct and check every use against its declaration. For example, an algebraic data type declares a set of cases, and the compiler checks that every use refers to one of these cases, and that every case is covered."),l.a.createElement(P,{name:"No global state"},"In Flix there is no global shared state. This avoids a plethora of issues, including difficulties with initialization order and race conditions in the presence of concurrency. A Flix programmer is free to construct some state in the main function and pass it around, but there is no built-in mechanism to declare global variables. In a real system, the programmer still has to deal with the state of the world, e.g. the state of the file system, the network, and other resources."),l.a.createElement(P,{name:"Share memory by communicating"},"Flix follows the Go mantra: ",l.a.createElement("a",{href:"https://blog.golang.org/share-memory-by-communicating"},l.a.createElement("i",null,"Do not communicate by sharing memory; instead, share memory by communicating."))," In other words: mutable memory should never be shared between processes. Processes should only share immutable messages (and data structures). We believe this significantly reduces the risk of ",l.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Race_condition"},"race conditions"),"."),l.a.createElement(P,{name:"Fail fast, fail hard"},"To aid debugging and prevent potential harmful behaviour, Flix aborts execution when an unrecoverable error is encountered. In the presence of concurrency, if a process fails, Flix aborts the entire program. This ensures that the outside environment is duly notified and can take corrective action, e.g. to restart the program."),l.a.createElement(P,{name:"No null value"},"Flix does not have the ",l.a.createElement("code",null,"null")," value. The null value is now widely considered a mistake and languages such as C#, Dart, Kotlin and Scala are scrambling to adopt mechanisms to ensure non-nullness. In Flix, we adopt the standard solution from functional languages which is to represent the absence of a value using the ",l.a.createElement("code",null,"Option")," type. This solution is simple to understand, works well, and guarantees the absence of dreaded ",l.a.createElement("code",null,"NullPointerException"),"s."),l.a.createElement(P,{name:"No implicit coercions"},"In Flix, a value of one type is never implicitly coerced or converted into a value of another type. For example,",l.a.createElement("ul",null,l.a.createElement("li",null,"No value is ever coerced to a boolean."),l.a.createElement("li",null,"No value is ever coerced to a string."),l.a.createElement("li",null,"Integers and floating-point are never truncated or promoted."))),l.a.createElement(P,{name:"No reflection"},"Flix does not support reflection, i.e. the ability to inspect the structure of the program at run-time. Reflection tends to break the kind of program reasoning that both compilers and humans rely on. At some point in the future, Flix might support some notion of compile-time meta programming."),l.a.createElement(P,{name:"No warnings, only errors"},"The Flix compiler never emits warnings; only compile-time errors which abort compilation. Warnings can be ignored or turned off. People disagree on whether a warning is harmless or not. For Flix, we believe that any code that appears troublesome or incorrect to the compiler should outright be rejected."),l.a.createElement(P,{name:"No dead or unreachable code"},"Inspired by ",l.a.createElement("a",{href:"https://doc.rust-lang.org/rust-by-example/attribute/unused.html"},"Rust"),", the Flix compiler will reject programs that contain dead or unreachable code. We believe that rejecting such programs will help programmers avoid mistakes where some algebraic data type or function is unintentionally left unused.",l.a.createElement("br",null),l.a.createElement(d.a,null,"in progress")),l.a.createElement(P,{name:"No Craze Following"},"A few years ago HTML was all the rage. Hence it was only natural that Java adopted HTML-style comments. A bit later, XML was all the rage, hence it was only natural that Scala added support for native XML literals. Today, JSON and Markdown are all the rage, but if history is any guide, we should not add any special support for these to Flix."),l.a.createElement(P,{name:"No blessed library"},"The Flix standard library is implemented in Flix. It has no special support from the compiler. If you don't like it or if you don't need it, you can replace it."),l.a.createElement(P,{name:"Minimal prelude"},"The Flix prelude contains algebraic data types and functions that are imported into every compilation unit. Therefore we aim to keep the prelude very small and only include extremely common functionality."),l.a.createElement(P,{name:"Exhaustive pattern matches"},"The Flix compiler enforces that pattern matches handle all cases of an algebraic data type. If a match expression is found to be non-exhaustive, the program is rejected. We believe this encourages more robust code and enables safer refactoring of algebraic data types.")))}}]),t}(a.Component),P=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){return l.a.createElement("div",null,l.a.createElement(d.d,null,l.a.createElement(d.e,null,l.a.createElement(d.i,null,this.props.name),this.props.children)))}}]),t}(a.Component),N=A,T=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="Flix | Contribute"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{md:"12"},l.a.createElement("h1",null,"Contribute"),l.a.createElement("p",null,"Flix is an open-source project and made freely available under the ",l.a.createElement("a",{href:"https://www.apache.org/licenses/LICENSE-2.0"},"Apache 2.0")," license."),l.a.createElement("p",null,"Most development is research-driven and takes place at ",l.a.createElement("a",{href:"http://cs.au.dk/research/programming-languages/"},"Aarhus University")," and the ",l.a.createElement("a",{href:"http://plg.uwaterloo.ca"}," University of Waterloo"),"."),l.a.createElement("p",null,"All source code is available online and hosted at ",l.a.createElement("a",{href:"https://github.com/flix/flix"},"GitHub"),". We organize development using GitHub ",l.a.createElement("a",{href:"https://github.com/flix/flix/issues"},"issues")," and on ",l.a.createElement("a",{href:"https://gitter.im/flix/Lobby"},"Gitter"),"."),l.a.createElement("p",null,"If you are interested in learning more about Flix or in working on Flix, please feel free to reach out."))),l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{md:"12"},l.a.createElement("h2",null,"Projects"),l.a.createElement("p",null,"We encourage students at Aarhus University and the University of Waterloo that are interested in compilers, programming language design, and implementation to reach out to us to learn about potential projects."),l.a.createElement(d.f,null,l.a.createElement(d.d,null,l.a.createElement(d.e,null,l.a.createElement(d.i,null,"Talent Track Projects"),l.a.createElement("p",null,"Aarhus University offers a talent track program for capable students that are in their second or third year of studies and are interested in working on a research project for up to one year as an extracurricular activity."),l.a.createElement("p",null,"We maintain a collection of ",l.a.createElement("a",{href:"https://github.com/flix/flix/labels/talent-track"},"talent track project ideas")," on GitHub."))),l.a.createElement(d.d,null,l.a.createElement(d.e,null,l.a.createElement(d.i,null,"Bachelor and Master Projects"),l.a.createElement("p",null,"If you are a bachelor or master student at Aarhus University you can write your thesis on a topic related to Flix."),l.a.createElement("p",null,"We maintain a collection of ideas for ",l.a.createElement("a",{href:"https://github.com/flix/flix/labels/bachelor-project"},"bachelor"),"- and ",l.a.createElement("a",{href:"https://github.com/flix/flix/labels/master-project"},"master")," level projects. But, we don't necessarily list all our project ideas, as some might involve research that we intend to publish. In any case, you should reach out to us to hear what is currently going on."))),l.a.createElement(d.d,null,l.a.createElement(d.e,null,l.a.createElement(d.i,null,"Research Collaboration"),l.a.createElement("p",null,"If you are a researcher interested in the space of programming language design and implementation, program analysis, logic programming, Datalog, or any other related topic, you should feel free to reach out to us to talk about potential collaboration."),l.a.createElement("p",null,"If you want to use Flix in your research, e.g. for program analysis, you are welcome to reach out to us for information about how to get started.")))))))}}]),t}(a.Component),M=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="Flix | Research"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement("h1",null,"Research"),l.a.createElement("p",null,"Research on Flix takes place at ",l.a.createElement("a",{href:"http://cs.au.dk/research/programming-languages/"},"Aarhus University")," and the ",l.a.createElement("a",{href:"http://plg.uwaterloo.ca"},"University of Waterloo"),"."),l.a.createElement("div",null,"A significant part of our research is centered on the Datalog aspects of Flix, including:",l.a.createElement("ul",null,l.a.createElement("li",null,"design of a language with first-class Datalog constraints."),l.a.createElement("li",null,"extensions of Datalog semantics to lattice semantics."),l.a.createElement("li",null,"implementation of efficient fixpoint engines."),l.a.createElement("li",null,"use of Flix for program analysis."),l.a.createElement("li",null,"verification of such program analyses."))),l.a.createElement("p",null,"As the above suggests, a major research focus is on how to write declarative program analyses using Flix that are correct and scalable. The workshop paper ",l.a.createElement("a",{href:"http://staticanalysis.org/tapas2016/abstracts/TAPAS_2016_MadsenEtAl.pdf"},"Programming a Dataflow Analysis in Flix")," gives a good introduction to this topic."),l.a.createElement("p",null,"Below is a selection of research papers published on Flix:"),l.a.createElement("h3",null,"Peer-Reviewed Conferences and Journals"),l.a.createElement("ul",null,l.a.createElement(R,{title:"Implicit Parameters for Logic Programming",authors:"Magnus Madsen, Ond\u0159ej Lhot\xe1k",venue:"PPDP '18",url:"https://dl.acm.org/citation.cfm?id=3236953"}),l.a.createElement(R,{title:"Safe and Sound Program Analysis with Flix",authors:"Magnus Madsen, Ond\u0159ej Lhot\xe1k",venue:"ISSTA '18",url:"https://dl.acm.org/citation.cfm?id=3213847"}),l.a.createElement(R,{title:"Tail Call Elimination and Data Representation for Functional Languages on the Java Virtual Machine",authors:"Magnus Madsen, Ramin Zarifi, Ond\u0159ej Lhot\xe1k",venue:"CC '18",url:"https://dl.acm.org/citation.cfm?id=3179499"}),l.a.createElement(R,{title:"From Datalog to Flix: A Declarative Language for Fixed Points on Lattices",authors:"Magnus Madsen, Ming-Ho Yee, Ond\u0159ej Lhot\xe1k",venue:"PLDI '16",url:"https://dl.acm.org/citation.cfm?id=2908096"})),l.a.createElement("h3",null,"Workshops"),l.a.createElement("ul",null,l.a.createElement(R,{title:"Programming a Dataflow Analysis in Flix",authors:"Magnus Madsen, Ming-Ho Yee, Ond\u0159ej Lhot\xe1k",venue:"TAPAS '16",url:"http://staticanalysis.org/tapas2016/abstracts/TAPAS_2016_MadsenEtAl.pdf"})),l.a.createElement("h3",null,"Theses"),l.a.createElement("ul",null,l.a.createElement(R,{title:"Implementing a Functional Language for Flix",authors:"Ming-Ho Yee",venue:"University of Waterloo",url:"https://uwspace.uwaterloo.ca/bitstream/handle/10012/10856/Yee_Ming-Ho.pdf?sequence=1"})))}}]),t}(a.Component),R=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){return l.a.createElement("li",{className:"mb-3"},l.a.createElement("a",{href:this.props.url},this.props.title)," ",l.a.createElement("b",null,"[",this.props.venue,"]"),l.a.createElement("br",null),this.props.authors)}}]),t}(a.Component),L=M,D=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="Flix | Documentation"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,null,l.a.createElement("h1",null,"Documentation"),l.a.createElement("p",null,"Documentation on Flix is currently a bit sparse. We hope to have better documentation in the future."),l.a.createElement("p",null,"The ",l.a.createElement("a",{href:"http://flix.github.io/programming-flix"},"Programming Flix")," book offers an introduction to Flix for programmers who are already familiar with functional programming."),l.a.createElement("p",null,"The ",l.a.createElement("a",{href:"http://flix.github.io/api/"},"Standard Library")," documentation provides a Javadoc-style description of the Flix API, including the operations available on important types such as ",l.a.createElement("code",null,"Option"),", ",l.a.createElement("code",null,"Result"),", and ",l.a.createElement("code",null,"List"),"."),l.a.createElement("p",null,"The research aspects of Flix are mostly described in the literature."))),l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,null,l.a.createElement("h3",null,"Programming Language Checklist"),l.a.createElement("p",null,"For completeness (and fun), here is the ",l.a.createElement("a",{href:"http://colinm.org/language_checklist.html"},"programming language check list")," for Flix:"),l.a.createElement("code",null,l.a.createElement("pre",null,'You appear to be advocating a new:\n[x] functional [x] imperative [ ] object-oriented [ ] procedural [ ] stack-based\n[x] "multi-paradigm" [ ] lazy [x] eager [x] statically-typed [ ] dynamically-typed\n[x] pure [x] impure [ ] non-hygienic [ ] visual [ ] beginner-friendly\n[ ] non-programmer-friendly [ ] completely incomprehensible\nprogramming language. Your language will not work. Here is why it will not work.\n\nYou appear to believe that:\n[x] Syntax is what makes programming difficult\n[x] Garbage collection is free [x] Computers have infinite memory\n[ ] Nobody really needs:\n[ ] concurrency [ ] a REPL [ ] debugger support [x] IDE support [ ] I/O\n[x] to interact with code not written in your language\n[ ] The entire world speaks 7-bit ASCII\n[ ] Scaling up to large software projects will be easy\n[x] Convincing programmers to adopt a new language will be easy\n[ ] Convincing programmers to adopt a language-specific IDE will be easy\n[ ] Programmers love writing lots of boilerplate\n[ ] Specifying behaviors as "undefined" means that programmers won\'t rely on them\n[ ] "Spooky action at a distance" makes programming more fun\n\nUnfortunately, your language (has/lacks):\n[h] comprehensible syntax [h] semicolons [ ] significant whitespace [ ] macros\n[ ] implicit type conversion [ ] explicit casting [h] type inference\n[ ] goto [ ] exceptions [h] closures [h] tail recursion [ ] coroutines\n[ ] reflection [ ] subtyping [ ] multiple inheritance [ ] operator overloading\n[h] algebraic datatypes [h] recursive types [h] polymorphic types\n[ ] covariant array typing [ ] monads [ ] dependent types\n[h] infix operators [ ] nested comments [ ] multi-line strings [ ] regexes\n[h] call-by-value [ ] call-by-name [ ] call-by-reference [ ] call-cc\n\nThe following philosophical objections apply:\n[ ] Programmers should not need to understand category theory to write "Hello, World!"\n[ ] Programmers should not develop RSI from writing "Hello, World!"\n[ ] The most significant program written in your language is its own compiler\n[x] The most significant program written in your language isn\'t even its own compiler\n[x] No language spec\n[x] "The implementation is the spec"\n[ ] The implementation is closed-source [ ] covered by patents [ ] not owned by you\n[ ] Your type system is unsound [ ] Your language cannot be unambiguously parsed\n[ ] a proof of same is attached\n[ ] invoking this proof crashes the compiler\n[ ] The name of your language makes it impossible to find on Google\n[ ] Interpreted languages will never be as fast as C\n[x] Compiled languages will never be "extensible"\n[ ] Writing a compiler that understands English is AI-complete\n[ ] Your language relies on an optimization which has never been shown possible\n[ ] There are less than 100 programmers on Earth smart enough to use your language\n[x] Hindley-Milner type inference takes exponential time\n\nYour implementation has the following flaws:\n[x] CPUs do not work that way\n[x] RAM does not work that way\n[ ] VMs do not work that way\n[ ] Compilers do not work that way\n[ ] Compilers cannot work that way\n[x] Shift-reduce conflicts in parsing seem to be resolved using rand()\n[ ] You require the compiler to be present at runtime\n[x] You require the language runtime to be present at compile-time\n[ ] Your compiler errors are completely inscrutable\n[ ] Dangerous behavior is only a warning\n[x] The compiler crashes if you look at it funny\n[ ] The VM crashes if you look at it funny\n[ ] You don\'t seem to understand basic optimization techniques\n[ ] You don\'t seem to understand basic systems programming\n[ ] You don\'t seem to understand pointers\n[ ] You don\'t seem to understand functions\n\nAdditionally, your marketing has the following problems:\n[ ] Unsupported claims of increased productivity\n[ ] Unsupported claims of greater "ease of use"\n[ ] Obviously rigged benchmarks\n[ ] Graphics, simulation, or crypto benchmarks where your code just calls\nhandwritten assembly through your FFI\n[ ] String-processing benchmarks where you just call PCRE\n[ ] Matrix-math benchmarks where you just call BLAS\n[ ] Noone really believes that your language is faster than:\n[ ] assembly [ ] C [ ] FORTRAN [ ] Java [ ] Ruby [ ] Prolog\n[ ] Rejection of orthodox programming-language theory without justification\n[ ] Rejection of orthodox systems programming without justification\n[ ] Rejection of orthodox algorithmic theory without justification\n[ ] Rejection of basic computer science without justification\n\nTaking the wider ecosystem into account, I would like to note that:\n[x] Your complex sample code would be one line in: Haskell, Prolog, Scala, ...\n[ ] We already have an unsafe imperative language\n[ ] We already have a safe imperative OO language\n[x] We already have a safe statically-typed eager functional language\n[ ] You have reinvented Lisp but worse\n[ ] You have reinvented Javascript but worse\n[ ] You have reinvented Java but worse\n[ ] You have reinvented C++ but worse\n[ ] You have reinvented PHP but worse\n[ ] You have reinvented PHP better, but that\'s still no justification\n[ ] You have reinvented Brainfuck but non-ironically\n\nIn conclusion, this is what I think of you:\n[x] You have some interesting ideas, but this won\'t fly.\n[ ] This is a bad language, and you should feel bad for inventing it.\n[ ] Programming in this language is an adequate punishment for inventing it.\n')))))}}]),t}(a.Component),W=n(57),H=n(55),B="wss://flix-evaluator.cs.au.dk/ws",U=function(e){function t(e){var n;Object(s.a)(this,t),(n=Object(m.a)(this,Object(u.a)(t).call(this,e))).runProgram=function(e,t){n.state.connected?(n.state.websocket.onmessage=function(e){console.log("Received reply from: "+B);var n=JSON.parse(e.data);console.log(n),t(n)},n.state.websocket.send(e)):console.log("Not connected yet")},console.log("Connecting to: "+B),n.state={connected:!1,websocket:null};try{n.state.websocket=new window.WebSocket(B),n.state.websocket.onopen=function(e){console.log("Connected to: "+B),n.setState({connected:!0})}}catch(a){console.log("Unable to connect: "+a)}return n}return Object(h.a)(t,e),Object(c.a)(t,[{key:"getHome",value:function(){return l.a.createElement(j,{flix:{connected:this.state.connected,run:this.runProgram.bind(this)}})}},{key:"render",value:function(){var e=this;return l.a.createElement(d.k,{className:"page"},l.a.createElement(d.o,{dark:!0,color:"info",expand:"md",className:"menu shadow-sm mb-4"},l.a.createElement(d.l,{className:"mr-lg-auto",navbar:!0},l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:H.a,to:"/"},"Home")),l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:H.a,to:"/getting-started/"},"Getting Started")),l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:H.a,to:"/principles/"},"Principles")),l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:H.a,to:"/research/"},"Research")),l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:H.a,to:"/documentation/"},"Documentation")),l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:H.a,to:"/contribute/"},"Contribute")))),l.a.createElement(W.a,{path:"/",exact:!0,render:function(){return e.getHome()}}),l.a.createElement(W.a,{path:"/getting-started/",exact:!0,component:S}),l.a.createElement(W.a,{path:"/principles/",exact:!0,component:N}),l.a.createElement(W.a,{path:"/research/",exact:!0,component:L}),l.a.createElement(W.a,{path:"/documentation/",exact:!0,component:D}),l.a.createElement(W.a,{path:"/contribute/",exact:!0,component:T}))}}]),t}(a.Component);o.a.render(l.a.createElement(i.a,null,l.a.createElement(U,null)),document.getElementById("root"))}},[[32,2,1]]]);
//# sourceMappingURL=main.bd705b30.chunk.js.map