(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{28:function(e,t,a){e.exports=a.p+"static/media/install.2fd58801.gif"},29:function(e,t,a){e.exports=a.p+"static/media/next-steps.5a84bcf8.gif"},32:function(e,t,a){e.exports=a(53)},39:function(e,t,a){},53:function(e,t,a){"use strict";a.r(t);var n=a(1),l=a.n(n),r=a(12),o=a.n(r),i=a(56),s=(a(37),a(4)),c=a(8),m=a(6),u=a(5),h=a(7),d=(a(39),a(2)),p=a(25),f=a.n(p),g=a(26),y=a.n(g),b=(a(49),a(50),function(e){function t(){var e;Object(s.a)(this,t);var a=(e=Object(m.a)(this,Object(u.a)(t).call(this))).createKeywordMapper({"support.function":"avg",keyword:"case|def|else|enum|if|lat|let|match|rel|select|spawn|with","constant.language":"true|false|Nil","storage.type":"Bool|Int|Str|Option|Result|List"},"identifier",!0);return e.$rules={start:[{token:"comment",regex:"\\/\\/.*$"},{token:"comment",start:"/\\*",end:"\\*/"},{token:"string",regex:'".*?"'},{token:"string",regex:"'.*?'"},{token:"string",regex:"`.*?`"},{token:"constant.numeric",regex:"[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"},{token:a,regex:"[a-zA-Z_$][a-zA-Z0-9_$]*\\b"},{token:"keyword.operator",regex:"\\+|\\-|\\/|\\/\\/|%|<@>|@>|<@|&|\\^|~|<|>|<=|=>|==|!=|<>|="},{token:"paren.lparen",regex:"[\\(]"},{token:"paren.rparen",regex:"[\\)]"},{token:"text",regex:"\\s+"}]},e.normalizeRules(),e}return Object(h.a)(t,e),t}(window.ace.acequire("ace/mode/text_highlight_rules").TextHighlightRules)),E=function(e){function t(){var e;return Object(s.a)(this,t),(e=Object(m.a)(this,Object(u.a)(t).call(this))).HighlightRules=b,e}return Object(h.a)(t,e),t}(window.ace.acequire("ace/mode/java").Mode),x=(a(51),function(e){function t(e){var a;return Object(s.a)(this,t),(a=Object(m.a)(this,Object(u.a)(t).call(this,e))).run=function(){a.setState({waiting:!0},function(){var e=a.state.input;a.props.flix.run(e,function(e){return a.setState({waiting:!1,output:e})})})},a.onChange=function(e){a.setState({input:e})},a.onRunClick=function(){a.run()},a.onResetClick=function(){a.setState(a.getInitialState())},a.resultBox=function(){return a.state.output?"success"===a.state.output.status?l.a.createElement(d.d,{body:!0,outline:!0,color:"success",className:"mt-2"},l.a.createElement(d.h,null,"Main returned: ",l.a.createElement("code",null,a.state.output.result))):l.a.createElement(d.d,{body:!0,outline:!0,color:"danger",className:"mt-2"},l.a.createElement(d.h,null,l.a.createElement("code",null,f()(a.state.output.result)))):void 0},a.state=a.getInitialState(),a}return Object(h.a)(t,e),Object(c.a)(t,[{key:"getInitialState",value:function(){return{input:this.props.code,output:void 0,waiting:!1}}},{key:"componentDidMount",value:function(){var e=new E;this.refs.aceEditor.editor.getSession().setMode(e)}},{key:"render",value:function(){return l.a.createElement("div",null,l.a.createElement("div",null,l.a.createElement("div",null,l.a.createElement(y.a,{mode:"text",theme:"chrome",ref:"aceEditor",showGutter:!1,showPrintMargin:!1,highlightActiveLine:!1,onChange:this.onChange,value:this.state.input,autoScrollEditorIntoView:!0,minLines:23,maxLines:23,editorProps:{$blockScrolling:!0}}),this.state.waiting),l.a.createElement(d.c,null,l.a.createElement(d.b,{color:"primary",outline:!0,className:"btn-xs",onClick:this.onRunClick},"Run Main"),l.a.createElement(d.b,{color:"secondary",outline:!0,className:"btn-xs",onClick:this.onResetClick},"Reset"))),this.resultBox())}}]),t}(n.Component)),w=function(){return[{name:"Algebraic Data Types and Pattern Matching",code:"/// An algebraic data type for shapes.\nenum Shape {\n    case Circle(Int),        // circle radius\n    case Square(Int),        // side length\n    case Rectangle(Int, Int) // height and width\n}\n\n/// Computes the area of the given shape using \n/// pattern matching and basic arithmetic.\ndef area(s: Shape): Int = match s with {\n    case Circle(r)       => 3 * (r * r)\n    case Square(w)       => w * w\n    case Rectangle(h, w) => h * w\n}\n\n// Computes the area of a 2 by 4.\ndef main(): Int = area(Rectangle(2, 4))\n"},{name:"Lists and List Processing",code:"/// In Flix, as in many functional programming languages, \n/// lists are the bread and butter.\n\n/// We can easily construct a list:\ndef aList(): List[Int] = 1 :: 2 :: 3 :: Nil\n\n/// We can easily append two lists:\ndef bList(): List[Int] = aList() ::: aList()\n\n/// We can use pattern matching to take a list apart:\ndef length[a](l: List[a]): Int = match l with {\n  case Nil     => 0\n  case x :: xs => 1 + length(xs) \n}\n\n/// The Flix library has extensive support for lists:\ndef main(): Bool = \n    let l1 = List.range(0, 10);\n    let l2 = List.intersperse(42, l1);\n    let l3 = List.map(x -> x :: x :: Nil, l2);\n    let l4 = List.flatten(l3);\n    List.exists(x -> x == 0, l4)\n"},{name:"Higher-Order Functions",code:"/// Returns the sum of x and y.\ndef add(x: Int, y: Int): Int = x + y\n\n/// Returns x plus one.\ndef inc(x: Int): Int = add(x, 1)\n\n/// Returns a function that applies f twice.\ndef twice(f: Int -> Int): Int -> Int = x -> f(f(x))\n\n/// Returns x plus two.\ndef two(x: Int): Int = twice(inc)(x)\n\n/// Returns 123 plus 4 = 127.\ndef main(): Int = twice(two)(123)\n"},{name:"Enums and Parametric Polymorphism",code:"/// An algebraic data type for binary trees\n/// where each leaf carries a value of type a.\nenum Tree[a] {\n    case Leaf(a),\n    case Node(Tree[a], Tree[a])\n}\n\n/// A higher-order function that transforms a tree with\n/// elements of type a to a tree with elements of type b.\ndef map[a, b](f: a -> b, t: Tree[a]): Tree[b] = \n  match t with {\n    case Leaf(x)    => Leaf(f(x))\n    case Node(l, r) => Node(map(f, l), map(f, r))        \n  }\n\n/// Returns a simple tree with two leafs.\ndef tree(): Tree[Int] = Node(Leaf(1), Leaf(2))\n\n/// Squares all elements in the simple tree.\ndef main(): Tree[Int] = map(x -> x * x, tree())\n"},{name:"Record Construction and Use",code:"/// Returns the area of the rectangle `r`.\n/// The record `r` must have `x` and `y` labels, and no other labels.\ndef area(r: {x: Int, y: Int}): Int = r.x * r.y\n\n/// Computes the area of various rectangle records.\n/// Note that the order of labels is immaterial.\ndef areas(): List[Int] =\n    area({x = 1, y = 2}) ::\n    area({y = 2, x = 3}) :: Nil\n\n/// Returns the area of the polymorphic record `r`.\n/// Note that the use of the type variable `a` permits the record `r`\n/// to have labels other than `x` and `y`.\ndef polyArea[a](r: {x: Int, y: Int | a}): Int = r.x * r.y\n\n/// Computes the area of various rectangle records.\n/// Note that some records have additional fields.\ndef polyAreas(): List[Int] =\n    polyArea({x = 1, y = 2}) ::\n    polyArea({x = 2, y = 3, z = 4}) :: Nil\n\ndef main(): List[Int] = polyAreas()\n"},{name:"Polymorphic Record Update",code:"/// Returns the record `r` with a new value of its `x` label.\ndef setX(r: {x: Int, y: Int}, v: Int): {x: Int, y: Int} =\n    { x = v | r }\n\n/// Returns the value 1 + 3 = 4.\ndef main2(): Int =\n    let r1 = {x = 1, y = 2};\n    let r2 = setX(r1, 3);\n    r1.x + r2.x\n\n/// Returns the record `r` with a new value of its `y` label.\n/// Preserves (retains) all other labels polymorphically.\ndef setY[a](r: {y: Int | a}, v: Int): {y: Int | a} =\n    { y = v | r }\n\n/// Returns the value 0 + 1 + 3 = 4.\ndef main(): Int =\n    let r1 = {x = 1, y = 2};\n    let r2 = {x = 1, y = 2, z = 3};\n    let r3 = setY(r1, 0);\n    let r4 = setY(r2, 1);\n    r3.y + r4.y + r4.z\n"},{name:"Polymorphic Record Extension and Restriction",code:'/// Polymorphically extends the record `r` with an `age` label.\n/// Preserves (retains) all other labels polymorphically.\ndef withAge[a](r: a, v: Int): {age: Int | a} =\n    { +age = v | r }\n\n/// Polymorphically restricts (removes) the `age` label from `r`.\n/// Preserves (retains) all other labels polymorphically.\ndef withoutAge[a](r: {age: Int | a}): a = {-age | r}\n\n/// Construct several records and extend them with an age.\ndef main(): Int =\n    let r1 = withAge({fstName = "Julius", lstName = "Caesar"}, 55);\n    let r2 = withAge({monument = "Flavian Amphitheatre"}, 2019 - 80);\n    let r3 = withAge({country = "United States"}, 2019 - 1776);\n    r1.age + r2.age + r3.age\n\n/// Constructs a record, extends it with an age, and restricts it.\ndef main2(): Unit =\n    let r1 = {fstName = "Julius", lstName = "Caesar"};\n    let r2 = withAge(r1, 55);\n    let r3 = withoutAge(r2);\n    ()\n'},{name:"Function Composition, Pipelines, and Currying",code:"/// Flix supports function composition with\n/// the |> operator (among others) and currying.\n/// This makes it easy to construct pipelines:\n                \n/// Constructs a list with ten elements and performs\n/// various operations on it in a pipeline.\ndef main(): Bool = \n    List.range(0, 10) |>\n    List.map(x -> x * x) |>\n    List.take(5) |> \n    List.exists(x -> x == 1)\n"},{name:"Uniform Function Call Syntax (UFCS)",code:"/// Returns x plus one.\ndef inc(x: Int): Int = x + 1\n\n/// Returns the sum of x and y.\ndef sum(x: Int, y: Int): Int = x + y\n\n/// We can call these functions in the standard way:\ndef main(): Int = \n    let i = inc(123);\n    let s = sum(123, 456);\n        i + s\n\n/// Or with uniform function call syntax:\ndef main2(): Int = \n    let i = 123.inc();\n    let s = 123.sum(456);\n        i + s\n\n/// Or even using an infix notation for sum:\ndef main3(): Int = \n    let s = 123 `sum` 456;\n        s\n"},{name:"Mutual Recursion with Full Tail-Call Elimination",code:"/// Flix, despite being a JVM-language, \n/// supports full tail call elimination.\n\n/// We can demonstrate this with a naive implementation\n/// of a program that computes if a number is odd.\n\n/// Returns true if n is odd.\ndef isOdd(n: Int): Bool = \n    if (n == 0) false else isEvn(n - 1)\n\n/// Returns true if n is even.\ndef isEvn(n: Int): Bool = \n    if (n == 0) true else isOdd(n - 1)\n\n/// We can now compute if 12345 is odd.\n/// In a language without TCE this would\n/// quickly consume all stack space.\ndef main(): Bool = isOdd(12345)\n"},{name:"Sending and Receiving on Channels",code:"/// A function that sends every element of a list\ndef send(o: Channel[Int], l: List[Int]): Unit =\n    match l with {\n        case Nil     => ()\n        case x :: xs => o <- x; send(o, xs)\n    }\n\n/// A function that receives n elements \n/// and collects them into a list.\ndef recv(i: Channel[Int], n: Int): List[Int] =\n    match n with {\n        case 0 => Nil\n        case _ => (<- i) :: recv(i, n - 1)\n    }\n\n/// A function that calls receive and sends the result on d.\ndef wait(i: Channel[Int], n: Int, d: Channel[List[Int]]): Unit =\n    d <- recv(i, n);\n    ()\n\n/// Spawn a process for send and wait, and print the result.\ndef main(): List[Int] =\n    let l = 1 :: 2 :: 3 :: Nil;\n    let c = chan Int 100;\n    let d = chan List[Int] 100;\n    spawn send(c, l);\n    spawn wait(c, List.length(l), d);\n    <- d\n"},{name:"Using Channels and Select",code:' /// Mooo\'s `n` times on channel `c`.\ndef mooo(c: Channel[Str], n: Int): Unit = match n with {\n    case 0 => ()\n    case n => c <- "Mooo!"; mooo(c, n - 1)\n}\n\n/// Meow\'s `n` times on channel `c`.\ndef meow(c: Channel[Str], n: Int): Unit = match n with {\n    case 0 => ()\n    case n => c <- "Meow!"; meow(c, n - 1)\n}\n\n/// Hiss\'es `n` times on channel `c`.\ndef hiss(c: Channel[Str], n: Int): Unit = match n with {\n    case 0 => ()\n    case n => c <- "Hiss!"; hiss(c, n - 1)\n}\n\n/// Start the animal farm...\ndef main(): Str =\n    let c1 = chan Str 1;\n    let c2 = chan Str 1;\n    let c3 = chan Str 1;\n    spawn mooo(c1, 0);\n    spawn meow(c2, 3);\n    spawn hiss(c3, 7);\n    select {\n        case mooo <- c1 => mooo\n        case meow <- c2 => meow\n        case hiss <- c3 => hiss\n    }\n'},{name:"Select with Defaults and Timers",code:"/// Sends the value `x` on the channel `c` after a delay.\ndef slow(x: Int, c: Channel[Int]): Unit =\n    sleep(Duration.oneMinute());\n    c <- x;\n    ()\n\n/// Reads a value from the channel `c`.\n/// Returns the default value `1` if `c` is not ready.\ndef recvWithDefault(c: Channel[Int]): Int = select {\n    case x <- c => x\n    case _      => 1\n}\n\n/// Reads a value from the channel `c`.\n/// Returns the default value `2` if after a timeout.\ndef recvWithTimeout(c: Channel[Int]): Int = select {\n    case x <- c                   => x\n    case y <- Timer.seconds(1i64) => 2\n}\n\n/// Creates two channels `c1` and `c2`.\n/// Sends values on both after one minute.\n/// Receives from both using defaults and timeouts.\ndef main(): Int = {\n  let c1 = chan Int 1;\n  let c2 = chan Int 1;\n  spawn slow(123, c1);\n  spawn slow(456, c2);\n  recvWithDefault(c1) + recvWithTimeout(c2)\n}\n"},{name:"Fixpoint Computations with Top-Level Constraints",code:"/// We can use Flix as an ordinary Datalog solver.\n\n/// Declare two predicate symbols.\nrel DirectedEdge(x: Int, y: Int)\nrel Connected(x: Int, y: Int)\n\n/// Declare some edge facts.\nDirectedEdge(1, 2).\nDirectedEdge(2, 3).\nDirectedEdge(2, 4).\nDirectedEdge(3, 5).\n\n// Declare some constraints.\nConnected(x, y) :- DirectedEdge(x, y).\nConnected(x, z) :- Connected(x, y), DirectedEdge(y, z).\n"},{name:"First-Class Constraints and Fixpoints",code:'/// Declare two predicate symbols.\nrel ParentOf(x: Str, y: Str)\nrel AncestorOf(x: Str, y: Str)\n\n/// Returns a collection of facts.\ndef getFacts(): Schema { ParentOf, AncestorOf } = {\n    ParentOf("Pompey", "Strabo").\n    ParentOf("Gnaeus", "Pompey").\n    ParentOf("Pompeia", "Pompey").\n    ParentOf("Sextus", "Pompey").\n}\n\n/// Returns a collection of rules to compute ancestors.\ndef getRules(): Schema { ParentOf, AncestorOf } = {\n    AncestorOf(x, y) :- ParentOf(x, y).\n    AncestorOf(x, z) :- AncestorOf(x, y), AncestorOf(y, z).\n}\n\n/// Composes the facts and rules, and computes the lfp.\ndef main(): Schema { ParentOf, AncestorOf } =\n    solve getFacts() <+> getRules()\n'},{name:"Polymorphic First-Class Constraints",code:'/// Declare two polymorphic predicate symbols.\n/// Here an edge and a path are labelled with some type `l`.\nrel LabelEdge[l](x: Str, l: l, y: Str)\nrel LabelPath[l](x: Str, l: l, y: Str)\n\n/// Returns a set of edge facts labelled with numbers.\n/// Note that the return type is `closed` which means that the\n/// facts can *only* be used within a constraint system that\n/// has labelled edges and paths of ints.\ndef getEdgesWithNumbers(): Schema { LabelEdge[Int], LabelPath[Int] } = {\n    LabelEdge("a", 1, "b").\n    LabelEdge("b", 1, "c").\n    LabelEdge("c", 2, "d").\n}\n\n/// Returns a set of edge facts labelled with colors (strings).\n/// Note that the return type is `open` (polymorphic) which\n/// means that the facts can be used within any constraint\n/// as long as the edges are labelled with strings.\ndef getEdgesWithColor[r](): Schema { LabelEdge[Str] | r } = {\n    LabelEdge("a", "red", "b").\n    LabelEdge("b", "red", "c").\n    LabelEdge("c", "blu", "d").\n}\n\n/// Returns a set of polymorphic rules to compute the transitive\n/// closure of edges with the *same* label.\ndef getRules[l](): Schema { LabelEdge[l], LabelPath[l] } = {\n    LabelPath(x, l, y) :- LabelEdge(x, l, y).\n    LabelPath(x, l, z) :- LabelPath(x, l, y), LabelPath(y, l, z).\n}\n\n/// Computes the fixpoint of the two sets of facts with the rules.\n/// Note that polymorphism allow us to use `getRules`\n/// with both types of facts.\ndef main(): Unit =\n    let r1 = solve getEdgesWithColor() <+> getRules();\n    let r2 = solve getEdgesWithNumbers() <+> getRules();\n    ()\n\n/// However, the type system ensures that we do not mix facts of\n/// different type:\ndef main2(): Unit =\n    /// Uncomment to see that the composition does not type check:\n    /// let r1 = solve getEdgesWithColor() <+> getEdgesWithNumbers();\n    ()\n'},{name:"Pipelines of Fixpoint Computations",code:'// Declare three predicate symbols.\nrel ColorEdge(x: Int, c: Str, y: Int)\nrel ColorPath(x: Int, c: Str, y: Int)\nrel ColorlessPath(x: Int, y: Int)\n\ndef main(): Bool =\n    // Introduce some facts for colored paths.\n    let f1 = {\n        ColorEdge(1, "blue", 2).\n        ColorEdge(2, "blue", 3).\n    };\n    // Introduce some rules for computing paths.\n    let r1 = {\n        ColorPath(x, c, y) :- ColorEdge(x, c, y).\n        ColorPath(x, c, z) :- ColorPath(x, c, y), ColorEdge(y, c, z).\n    };\n    // Introduce some rules for computing colorless paths.\n    let r2 = {\n        ColorlessPath(x, y) :- ColorPath(x, _, y).\n    };\n    // Compute all the color paths.\n    let m1 = solve (f1 <+> r1);\n\n    // Use that result to compute colorless paths.\n    let m2 = solve (m1 <+> r2);\n\n    // Check that there is a path from 1 to 3.\n    m2 |= ColorlessPath(1, 3).\n'},{name:"An Interpreter for a Trivial Expression Language",code:"//\n// We define an adt to capture the syntax of arithmetic expressions.\n//\nenum AExp {\n    // a literal integer constant.\n    case Cst(Int),\n\n    // a binary addition expression: e1 + e2.\n    case Plus(AExp, AExp),\n\n    // a binary subtraction expression: e1 - e2.\n    case Minus(AExp, AExp),\n\n    // a binary multiplication expression: e1 * e2.\n    case Times(AExp, AExp),\n\n    // a binary division expression: e1 / e2.\n    case Divide(AExp, AExp),\n\n    //n a if-then-else expression: if (e1) e2 else e3.\n    case IfThenElse(BExp, AExp, AExp)\n}\n\n//\n// We then define an adt to capture the syntax of boolean expressions.\n//\nenum BExp {\n    // the true boolean literal.\n    case True,\n\n    // the false boolean literal.\n    case False,\n\n    // a logical negation expression: !e.\n    case Not(BExp),\n\n    // a logical conjunction expression: e1 && e2.\n    case Conj(BExp, BExp),\n\n    // a logical disjunction expression: e1 || e2.\n    case Disj(BExp, BExp),\n\n    // an equality of expression: e1 == e2.\n    case Eq(AExp, AExp),\n\n    // an inequality of expression: e1 != e2.\n    case Neq(AExp, AExp)\n}\n\n//\n// We now define a small interpreter for arithmetic expressions.\n//\ndef evalAExp(e: AExp): Int = match e with {\n    case Cst(i)                 => i\n    case Plus(e1, e2)           => evalAExp(e1) + evalAExp(e2)\n    case Minus(e1, e2)          => evalAExp(e1) - evalAExp(e2)\n    case Times(e1, e2)          => evalAExp(e1) * evalAExp(e2)\n    case Divide(e1, e2)         => evalAExp(e1) / evalAExp(e2)\n    case IfThenElse(e1, e2, e3) =>\n        let cond = evalBExp(e1);\n            if (cond) evalAExp(e2) else evalAExp(e3)\n}\n\n//\n// and here is the small interpreter for boolean expressions.\n//\ndef evalBExp(e: BExp): Bool = match e with {\n    case True           => true\n    case False          => false\n    case Not(e)         => !evalBExp(e)\n    case Conj(e1, e2)   => evalBExp(e1) && evalBExp(e2)\n    case Disj(e1, e2)   => evalBExp(e1) || evalBExp(e2)\n    case Eq(e1, e2)     => evalAExp(e1) == evalAExp(e2)\n    case Neq(e1,e2)     => evalAExp(e1) != evalAExp(e2)\n}\n\n\n// We can now run it!\ndef main(): Int = evalAExp(\n    IfThenElse(Neq(Cst(1), Cst(2)), Cst(42), Cst(21))\n)\n"}]},v=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="The Flix Programming Language"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{xs:"6"},l.a.createElement("h1",null,"The Flix Programming Language"),l.a.createElement("p",null,"Flix is a principled and opinionated functional programming language that takes inspiration from F#, Go, OCaml, Haskell, Rust, and Scala."),l.a.createElement("p",null,"Flix visually resembles Scala, but its type system is closer to that of OCaml and Haskell. Its concurrency model is inspired by Go-style processes and channels."),l.a.createElement("p",null,"Flix compiles to JVM bytecode and runs on the Java Virtual Machine. Flix supports full tail call elimination which means that tail calls (even to other functions) never overflow the stack."),l.a.createElement("p",null,"Flix performance is typically within 1-3x of equivalent Scala code."),l.a.createElement("p",null,"Research on Flix explores connections between functional and logic programming in the area of declarative fixpoint computations.")),l.a.createElement(d.j,{xs:"6"},l.a.createElement(k,{flix:this.props.flix}))),l.a.createElement("hr",{className:"mb-3"}),l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{md:"12"},l.a.createElement("h2",null,"Features at a Glance")),l.a.createElement(d.j,{md:"4",style:{fontSize:"1.2em"}},l.a.createElement("ul",null,l.a.createElement("li",null,"algebraic data types"),l.a.createElement("li",null,"pattern matching"),l.a.createElement("li",null,"first-class functions"),l.a.createElement("li",null,"extensible records"),l.a.createElement("li",null,"parametric polymorphism"),l.a.createElement("li",null,"Hindley-Milner type inference"))),l.a.createElement(d.j,{md:"4",style:{fontSize:"1.2em"}},l.a.createElement("ul",null,l.a.createElement("li",null,"CSP-style concurrency"),l.a.createElement("li",null,"buffered & unbuffered channels"),l.a.createElement("li",null,"first-class datalog constraints"),l.a.createElement("li",null,"stratified negation"),l.a.createElement("li",null,"unboxed primitives"),l.a.createElement("li",null,"expressions holes"))),l.a.createElement(d.j,{md:"4",style:{fontSize:"1.2em"}},l.a.createElement("ul",null,l.a.createElement("li",null,"full tail call elimination"),l.a.createElement("li",null,"compilation to JVM bytecode"),l.a.createElement("li",null,"core standard library"),l.a.createElement("li",null,"human friendly errors"),l.a.createElement("li",null,"interactive mode")))),l.a.createElement("hr",{className:"mb-3"}),l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{xs:"6"},l.a.createElement("h3",null,"Recent News"),l.a.createElement("ul",null,[{name:"Flix version 0.5.0 released with support for extensible records and unbuffered channels. Thanks Miguel Angelo Nicolau Fialho for help with the backend!",date:"2019-02-26"},{name:"Flix version 0.4.0 released!",date:"2019-01-03"},{name:"The new Flix website is now online!",date:"2019-01-03"},{name:"Jonathan and Simon are working on Go-style processes and channels for Flix.",date:"2018-12-20"},{name:"The paper entitled: 'Implicit Parameters for Logic Programming' is now available.",date:"2018-09-03"}].map(function(e){return l.a.createElement("li",{key:e.name},e.date," - ",e.name,l.a.createElement("br",null))}))),l.a.createElement(d.j,{xs:"6"},l.a.createElement("h3",null,"Bread- and Butter Functional Programming"),l.a.createElement("p",null,"Flix supports the basic building blocks of typed functional programs: algebraic data types, pattern matching, and parametric polymorphism (generics). It uses a Hindley-Milner style type system which supports type inference within a function. Its syntax is inspired by Scala with an emphasis on the use of keywords."))),l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{xs:"6"},l.a.createElement("h3",null,"Process and Channel-based Concurrency"),l.a.createElement("p",null,"Flix embraces a Go-style concurrency model based on processes and channels. Processes communicate by sharing immutable messages which help prevent race conditions. The current implementation is based on threads, but when the JVM gains support for light-weight threads or continuations, we plan to switch to one of those.")),l.a.createElement(d.j,{xs:"6"},l.a.createElement("h3",null,"Principled Design"),"It is our goal to build Flix on a solid foundation of ideas from programming language research. In our design, we try to identify and guide ourselves by a collection of principles each with a well-documented rationale. We want Flix to adopt great ideas from languages such as F#, Go, OCaml, Haskell, Rust, and Scala.")),l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{xs:"6"},l.a.createElement("h3",null,"Planned Features"),l.a.createElement("p",null,"At the moment, Flix has the feature set of a ML-style language. We are actively working on adding support for two features essential to real-world programming: an abstraction mechanism based on ",l.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Type_class"},"type classes")," and an ",l.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Effect_system"},"effect system")," to allow safe interaction with the outside world.")),l.a.createElement(d.j,{xs:"6"},l.a.createElement("h3",null,"Research and Flix"),l.a.createElement("p",null,"Flix is also a research project which explores various aspects of programming language design. A large part of the research is on connections between functional and logic programming, specifically Datalog. Flix, as probably the only language in the world, supports first-class Datalog constraints enriched with lattice semantics."),l.a.createElement("p",null,"For more information, we refer to our research papers."))),l.a.createElement("hr",{className:"mb-3"}),l.a.createElement(d.p,{className:"mb-3 pb-3"},l.a.createElement(d.j,{xs:"12"},l.a.createElement("p",{className:"small float-right"},"We kindly thank ",l.a.createElement("a",{href:"https://www.ej-technologies.com/"},"EJ Technologies")," for providing us with ",l.a.createElement("a",{href:"https://www.ej-technologies.com/products/jprofiler/overview.html"},"JProfiler")," and ",l.a.createElement("a",{href:"https://www.jetbrains.com/"},"JetBrains")," for providing us with ",l.a.createElement("a",{href:"https://www.jetbrains.com/idea/"},"IntelliJ IDEA"),"."))))}}]),t}(n.Component),k=function(e){function t(e){var a;Object(s.a)(this,t),a=Object(m.a)(this,Object(u.a)(t).call(this,e));var n,l=w(),r=(n=l.length,Math.floor(Math.random()*Math.floor(n)));return a.state={choice:r,samples:l},a}return Object(h.a)(t,e),Object(c.a)(t,[{key:"onChange",value:function(e){var t=e.target.value;this.setState({choice:t})}},{key:"getEditor",value:function(){var e=this.state.choice,t=this.state.samples[e];return l.a.createElement(x,{key:t.name,flix:this.props.flix,code:t.code,lines:18},t.code)}},{key:"isConnected",value:function(){return this.props.flix.connected?l.a.createElement(d.a,{color:"info",className:"float-right mt-1"},"Connected"):l.a.createElement(d.a,{color:"secondary",className:"float-right mt-1"},"Disconnected")}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement("select",{className:"mb-2",value:this.state.choice,onChange:this.onChange.bind(this)},this.state.samples.map(function(e,t){return l.a.createElement("option",{key:t,value:t},e.name)})),this.isConnected(),this.getEditor())}}]),t}(n.Component);var F=v,I=a(28),j=a.n(I),C=a(29),A=a.n(C),O=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="Flix | Getting Started"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement("h1",null,"Getting Started"),l.a.createElement("p",null,"Flix runs on any platform that supports the Java Virtual Machine. Installation is as easy as downloading and running a jar file."),l.a.createElement(d.p,{className:"mb-lg-5"},l.a.createElement(d.j,{md:"12"},l.a.createElement("h2",null,"Up and Running")),l.a.createElement(d.j,{md:"6"},l.a.createElement("ol",null,l.a.createElement("li",{className:"mb-2"},"Ensure that you have Java 11 or later installed. You can check your Java version with the command ",l.a.createElement("code",null,"java -version"),". You should see something like ",l.a.createElement("code",null,'openjdk version "11.0.1"'),"."),l.a.createElement("li",{className:"mb-2"},"Download ",l.a.createElement("a",{href:"https://github.com/flix/flix/releases"},"flix.jar")," from the GitHub releases page."),l.a.createElement("li",{className:"mb-2"},"Run the command ",l.a.createElement("code",null,"java -jar flix.jar --version")," to verify that you have the expected version of Flix."),l.a.createElement("li",{className:"mb-2"},"Run the command ",l.a.createElement("code",null,"java -jar flix.jar")," to start Flix in interactive mode with a read-eval-print loop."),l.a.createElement("li",{className:"mb-2"},"Enter any expression to have it evaluated, e.g. ",l.a.createElement("code",null,"21 + 42"),"."))),l.a.createElement(d.j,{md:"6"},l.a.createElement(d.d,{className:"p-2"},l.a.createElement(d.g,{top:!0,src:j.a})))),l.a.createElement(d.p,{className:"mb-lg-5"},l.a.createElement(d.j,{md:"12"},l.a.createElement("h2",null,"Next Steps: Using a File")),l.a.createElement(d.j,{md:"6"},l.a.createElement(d.d,{className:"p-2"},l.a.createElement(d.g,{top:!0,src:A.a}))),l.a.createElement(d.j,{md:"6"},l.a.createElement("ol",null,l.a.createElement("li",{className:"mb-2"},"Create the file ",l.a.createElement("code",null,"test.flix")," with the content:",l.a.createElement(d.d,null,l.a.createElement(d.e,null,l.a.createElement(d.h,null,l.a.createElement("code",null,"def main(): Unit = ()"))))),l.a.createElement("li",{className:"mb-2"},"Run the command ",l.a.createElement("code",null,"java -jar flix.jar test.flix --interactive")," to start Flix in interactive mode with the file loaded."),l.a.createElement("li",{className:"mb-2"},"Type ",l.a.createElement("code",null,"main()")," into the command prompt to run the main function."),l.a.createElement("li",{className:"mb-2"},"Type ",l.a.createElement("code",null,":w")," to watch the file for changes. You can now edit ",l.a.createElement("code",null,"test.flix")," as much as you want. Every time you save, Flix will automatically reload the file, and print any errors.")))))}}]),t}(n.Component),S=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="Flix | Principles"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement("h1",null,"Design Principles"),l.a.createElement("p",{className:"mb-3"},"We believe that the development of a programming language should follow a set of principles. That is, when a design decision is made there should exist some rationale for why that decision was made. By outlining these principles, as we develop Flix, we hope to keep ourselves honest and to communicate the kind of language Flix aspires to be."),l.a.createElement("p",{className:"mb-3"},"Many of these ideas and principles come from languages that have inspired Flix, including Ada, Elm, F#, Go, Haskell, OCaml, Rust, and Scala."),l.a.createElement(d.f,null,l.a.createElement(N,{name:"Simple is not easy"},"We believe in Rich Hickey's creed: ",l.a.createElement("a",{href:"https://www.infoq.com/presentations/Simple-Made-Easy"},"simple is not easy"),". We prefer a language that gets things right to one that makes things easy. Such a language might take longer to learn in the short run, but its simplicity pays off in the long run."),l.a.createElement(N,{name:"Everything is an expression"},"Flix is a functional language and embraces the idea that everything should be an expression. Flix has no local variable declarations or if-then-else statements, instead it has let-bindings and if-then-else expressions. However, Flix does not take this idea as far as the Scheme languages. Flix still has declarations, namespaces, and so forth that are not expressions."),l.a.createElement(N,{name:"Developer productivity over runtime performance"},"Flix aims to support developer productivity; the ability to do a lot with little ceremony or boilerplate. A hand-crafted C program might run faster than a Flix program, but it won't be as short, concise, or expressive as the Flix program. Flix aims to be a language with powerful constructs and high-level abstractions. This does not mean that Flix is slow."),l.a.createElement(N,{name:"Correctness over performance"},"Flix aims to ensure program correctness and considers it more important than raw performance. Languages such as C and C++ often rely on undefined behaviour to achieve stellar performance, whereas most other languages, including Flix, try to eschew undefined behaviour in favor of runtime checks for things that are hard to statically ensure. For example, most languages will dynamically check that array accesses are not out of bounds. The cost is a small performance hit, but in our view the benefit towards correctness is immense. Inspired by Ada, Flix aims to offer strong guarantees, ideally ensured statically, but when necessary with dynamic checks.",l.a.createElement("br",null),l.a.createElement(d.a,null,"in progress")),l.a.createElement(N,{name:"Local type inference"},"The Flix type system is based on ",l.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"},"Hindley-Milner")," which supports full type inference. As a design choice, we require all functions to be annotated with their argument and return types. We believe that requiring type signatures has three distinct advantages that outweigh the disadvantages.",l.a.createElement("ol",null,l.a.createElement("li",null,"Type signatures are useful as documentation and to aid program understanding."),l.a.createElement("li",null,"Type signatures accurately assign blame for type errors."),l.a.createElement("li",null,"Type signatures enable parallel type checking.")),"Of these, we think the former two are significantly more important than the latter."),l.a.createElement(N,{name:"Uniform function call syntax"},"Flix supports ",l.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax"},"uniform function call syntax (UFCS)"),". In Flix, the syntax for function application is: ",l.a.createElement("code",null,"f(a, b, c)"),'. UFCS enables an "object-oriented" style where we can write the same function call as ',l.a.createElement("code",null,"a.f(b, c)"),". As another example, the function call ",l.a.createElement("code",null,"length(xs)")," can also be written as ",l.a.createElement("code",null,"xs.length()"),". UFCS is a purely syntactic mechanism and does not influence the semantics of a call."),l.a.createElement(N,{name:"Keyword-based syntax"},"The Flix syntax is inspired by Scala. We believe that short key words make it easy to visually identify the overall structure of a piece of code. Flix tries to use three letter keywords were appropriate: ",l.a.createElement("code",null,"def"),", ",l.a.createElement("code",null,"let"),", ",l.a.createElement("code",null,"law"),",",l.a.createElement("code",null,"rel"),", but not for commonly established concepts: ",l.a.createElement("code",null,"if ... else "),"and ",l.a.createElement("code",null,"match .... with"),"."),l.a.createElement(N,{name:"Consistent syntax"},"Flix aims to have consistent and predictable syntax. As an example, we try to have the syntax of types mirror that of expressions:",l.a.createElement("ul",null,l.a.createElement("li",null,"A function application is written as ",l.a.createElement("code",null,"f(a, b, c)")," whereas a type application is written as ",l.a.createElement("code",null,"f[a, b, c]"),"."),l.a.createElement("li",null,"A function expression is written as ",l.a.createElement("code",null,"x -> x + 1")," whereas a function type is written as ",l.a.createElement("code",null,"Int -> Int"),"."),l.a.createElement("li",null,"A tuple is written as ",l.a.createElement("code",null,"(true, 12345)")," whereas a tuple type is written as ",l.a.createElement("code",null,"(Bool, Int)"),"."))),l.a.createElement(N,{name:"Human-readable errors"},"In the spirit of ",l.a.createElement("a",{href:"https://elm-lang.org/blog/compilers-as-assistants"},"Elm")," and ",l.a.createElement("a",{href:"https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html"},"Rust"),", Flix aims to have human readable and understandable compiler messages. Messages should describe the problem in detail and provide information about the context, including suggestions for how to correct the problem."),l.a.createElement(N,{name:"Private by default"},"Flix embraces the principle of least privilege. In Flix, declarations are hidden by default (i.e. private) and cannot be accessed from outside of their namespace (or sub-namespaces). We believe it is important that programmers are forced to make a conscious choice about when to make a declaration publicly visible."),l.a.createElement(N,{name:"Closed world assumption"},"Flix requires all code to be available at compile-time. This enables a range of compilation techniques, such as:",l.a.createElement("ul",null,l.a.createElement("li",null,"Monomorphization to avoid unnecessary boxing of primitives."),l.a.createElement("li",null,'Aggressive dead code elimination ("tree shaking") to remove unused functions.'),l.a.createElement("li",null,"Inlining across namespaces."),l.a.createElement("li",null,"Whole-program analysis."))),l.a.createElement(N,{name:"Illegal states should be unrepresentable"},"We believe that a language should make it easy to make illegal states unrepresentable. For example, algebraic data types can be used to precisely define the possible values of a type. In Flix, in the future, we want to take this a step further, and allow refinement of some types. For example, to express that some value must not only be an integer, but also that it must fall within a range, e.g. ",l.a.createElement("code",null,"[0-99]"),".",l.a.createElement("br",null),l.a.createElement(d.a,null,"in progress")),l.a.createElement(N,{name:"Nothing is executed before main"},"In Flix, ",l.a.createElement("code",null,"main")," is the entry point of a program. No (user-defined) code is ever executed before ",l.a.createElement("code",null,"main"),". No static initializers, no static fields. No class loaders. Main is always first. This makes it easy to reason about startup behavior."),l.a.createElement(N,{name:"Small, but comprehensive standard library"},"Flix has a small standard library with a few common data types, e.g. ",l.a.createElement("code",null,"Option"),", ",l.a.createElement("code",null,"List"),", ",l.a.createElement("code",null,"Set"),", and ",l.a.createElement("code",null,"Map"),", but for these it offers a comprehensive collection of functionality. For example, the standard library has more than 65 functions for working with lists. We want the standard library to offer a common set of abstractions which are usable by most programs, but not much else."),l.a.createElement(N,{name:"Declare before use"},"In Flix things must be defined before they can be used. Algebraic data types, functions, local variables, and other programming elements must be declared before they can be used by other program parts. Declarations make it easy to assign blame; we assume declarations to be correct and check every use against its declaration. For example, an algebraic data type declares a set of cases, and the compiler checks that every use refers to one of these cases, and that every case is covered."),l.a.createElement(N,{name:"No global state"},"In Flix there is no global shared state. This avoids a plethora of issues, including difficulties with initialization order and race conditions in the presence of concurrency. A Flix programmer is free to construct some state in the main function and pass it around, but there is no built-in mechanism to declare global variables. In a real system, the programmer still has to deal with the state of the world, e.g. the state of the file system, the network, and other resources."),l.a.createElement(N,{name:"Share memory by communicating"},"Flix follows the Go mantra: ",l.a.createElement("a",{href:"https://blog.golang.org/share-memory-by-communicating"},l.a.createElement("i",null,"Do not communicate by sharing memory; instead, share memory by communicating."))," In other words: mutable memory should never be shared between processes. Processes should only share immutable messages (and data structures). We believe this significantly reduces the risk of ",l.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Race_condition"},"race conditions"),"."),l.a.createElement(N,{name:"Bugs are not recoverable errors"},"We believe in the ",l.a.createElement("a",{href:"http://joeduffyblog.com/2016/02/07/the-error-model/"},"Midori Error Model"),"; that is, there are two kinds of errors: ",l.a.createElement("i",null,"recoverable errors")," and ",l.a.createElement("i",null,"program bugs"),". Recoverable errors are things like illegal user input, network errors, etc. Errors that can be anticipated and where there is a chance of recovery. Program bugs, on the other hand, are unanticipated and we cannot expect to recover from them. We should treat these two types of errors differently: For recoverable errors, we should enforce that they are checked and handled. For program bugs, we should terminate execution as quickly as possible to prevent data corruption and security issues."),l.a.createElement(N,{name:"Fail fast, fail hard"},"To aid debugging and prevent potential harmful behaviour, Flix aborts execution when an unrecoverable error is encountered. In the presence of concurrency, if a process fails, Flix aborts the entire program. This ensures that the outside environment is duly notified and can take corrective action, e.g. to restart the program."),l.a.createElement(N,{name:"No null value"},"Flix does not have the ",l.a.createElement("code",null,"null")," value. The null value is now widely considered a mistake and languages such as C#, Dart, Kotlin and Scala are scrambling to adopt mechanisms to ensure non-nullness. In Flix, we adopt the standard solution from functional languages which is to represent the absence of a value using the ",l.a.createElement("code",null,"Option")," type. This solution is simple to understand, works well, and guarantees the absence of dreaded ",l.a.createElement("code",null,"NullPointerException"),"s."),l.a.createElement(N,{name:"No implicit coercions"},"In Flix, a value of one type is never implicitly coerced or converted into a value of another type. For example,",l.a.createElement("ul",null,l.a.createElement("li",null,"No value is ever coerced to a boolean."),l.a.createElement("li",null,"No value is ever coerced to a string."),l.a.createElement("li",null,"Integers and floating-point are never truncated or promoted."))),l.a.createElement(N,{name:"No reflection"},"Flix does not support reflection, i.e. the ability to inspect the structure of the program at run-time. Reflection tends to break the kind of program reasoning that both compilers and humans rely on. At some point in the future, Flix might support some notion of compile-time meta programming."),l.a.createElement(N,{name:"No warnings, only errors"},"The Flix compiler never emits warnings; only compile-time errors which abort compilation. Warnings can be ignored or turned off. People disagree on whether a warning is harmless or not. For Flix, we believe that any code that appears troublesome or incorrect to the compiler should outright be rejected."),l.a.createElement(N,{name:"No dead or unreachable code"},"Inspired by ",l.a.createElement("a",{href:"https://doc.rust-lang.org/rust-by-example/attribute/unused.html"},"Rust"),", the Flix compiler will reject programs that contain dead or unreachable code. We believe that rejecting such programs will help programmers avoid mistakes where some algebraic data type or function is unintentionally left unused.",l.a.createElement("br",null),l.a.createElement(d.a,null,"in progress")),l.a.createElement(N,{name:"No fashion-driven development"},"A few years ago HTML was all the rage. Hence it was only natural that Java adopted HTML-style comments. A bit later, XML was all the rage, hence it was only natural that Scala added support for native XML literals. Today, JSON and Markdown are all the rage, but if history is any guide, we should not add any special support for these to Flix."),l.a.createElement(N,{name:"No blessed library"},"The Flix standard library is implemented in Flix. It has no special support from the compiler. If you don't like it or if you don't need it, you can replace it."),l.a.createElement(N,{name:"Minimal prelude"},"The Flix prelude contains algebraic data types and functions that are imported into every compilation unit. Therefore we aim to keep the prelude very small and only include extremely common functionality."),l.a.createElement(N,{name:"Exhaustive pattern matches"},"The Flix compiler enforces that pattern matches handle all cases of an algebraic data type. If a match expression is found to be non-exhaustive, the program is rejected. We believe this encourages more robust code and enables safer refactoring of algebraic data types.")))}}]),t}(n.Component),N=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){return l.a.createElement("div",null,l.a.createElement(d.d,null,l.a.createElement(d.e,null,l.a.createElement(d.i,null,this.props.name),this.props.children)))}}]),t}(n.Component),P=S,T=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="Flix | Contribute"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{md:"12"},l.a.createElement("h1",null,"Contribute"),l.a.createElement("p",null,"Flix is an open-source project and made freely available under the ",l.a.createElement("a",{href:"https://www.apache.org/licenses/LICENSE-2.0"},"Apache 2.0")," license."),l.a.createElement("p",null,"Most development is research-driven and takes place at ",l.a.createElement("a",{href:"http://cs.au.dk/research/programming-languages/"},"Aarhus University")," and the ",l.a.createElement("a",{href:"http://plg.uwaterloo.ca"}," University of Waterloo"),"."),l.a.createElement("p",null,"All source code is available online and hosted at ",l.a.createElement("a",{href:"https://github.com/flix/flix"},"GitHub"),". We organize development using GitHub ",l.a.createElement("a",{href:"https://github.com/flix/flix/issues"},"issues")," and on ",l.a.createElement("a",{href:"https://gitter.im/flix/Lobby"},"Gitter"),"."),l.a.createElement("p",null,"If you are interested in learning more about Flix or in working on Flix, please feel free to reach out."))),l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,{md:"12"},l.a.createElement("h2",null,"Projects"),l.a.createElement("p",null,"We encourage students at Aarhus University and the University of Waterloo that are interested in compilers, programming language design, and implementation to reach out to us to learn about potential projects."),l.a.createElement(d.f,null,l.a.createElement(d.d,null,l.a.createElement(d.e,null,l.a.createElement(d.i,null,"Talent Track Projects"),l.a.createElement("p",null,"Aarhus University offers a talent track program for capable students that are in their second or third year of studies and are interested in working on a research project for up to one year as an extracurricular activity."),l.a.createElement("p",null,"We maintain a collection of ",l.a.createElement("a",{href:"https://github.com/flix/flix/labels/talent-track"},"talent track project ideas")," on GitHub."))),l.a.createElement(d.d,null,l.a.createElement(d.e,null,l.a.createElement(d.i,null,"Bachelor and Master Projects"),l.a.createElement("p",null,"If you are a bachelor or master student at Aarhus University you can write your thesis on a topic related to Flix."),l.a.createElement("p",null,"We maintain a collection of ideas for ",l.a.createElement("a",{href:"https://github.com/flix/flix/labels/bachelor-project"},"bachelor"),"- and ",l.a.createElement("a",{href:"https://github.com/flix/flix/labels/master-project"},"master")," level projects. But, we don't necessarily list all our project ideas, as some might involve research that we intend to publish. In any case, you should reach out to us to hear what is currently going on."))),l.a.createElement(d.d,null,l.a.createElement(d.e,null,l.a.createElement(d.i,null,"Research Collaboration"),l.a.createElement("p",null,"If you are a researcher interested in the space of programming language design and implementation, program analysis, logic programming, Datalog, or any other related topic, you should feel free to reach out to us to talk about potential collaboration."),l.a.createElement("p",null,"If you want to use Flix in your research, e.g. for program analysis, you are welcome to reach out to us for information about how to get started.")))))))}}]),t}(n.Component),L=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="Flix | Research"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement("h1",null,"Research"),l.a.createElement("p",null,"Research on Flix takes place at ",l.a.createElement("a",{href:"http://cs.au.dk/research/programming-languages/"},"Aarhus University")," and the ",l.a.createElement("a",{href:"http://plg.uwaterloo.ca"},"University of Waterloo"),"."),l.a.createElement("div",null,"A significant part of our research is centered on the Datalog aspects of Flix, including:",l.a.createElement("ul",null,l.a.createElement("li",null,"design of a language with first-class Datalog constraints."),l.a.createElement("li",null,"extensions of Datalog semantics to lattice semantics."),l.a.createElement("li",null,"implementation of efficient fixpoint engines."),l.a.createElement("li",null,"use of Flix for program analysis."),l.a.createElement("li",null,"verification of such program analyses."))),l.a.createElement("p",null,"As the above suggests, a major research focus is on how to write declarative program analyses using Flix that are correct and scalable. The workshop paper ",l.a.createElement("a",{href:"http://staticanalysis.org/tapas2016/abstracts/TAPAS_2016_MadsenEtAl.pdf"},"Programming a Dataflow Analysis in Flix")," gives a good introduction to this topic."),l.a.createElement("p",null,"Below is a selection of research papers published on Flix:"),l.a.createElement("h3",null,"Peer-Reviewed Conferences and Journals"),l.a.createElement("ul",null,l.a.createElement(R,{title:"Implicit Parameters for Logic Programming",authors:"Magnus Madsen, Ond\u0159ej Lhot\xe1k",venue:"PPDP '18",url:"https://dl.acm.org/citation.cfm?id=3236953"}),l.a.createElement(R,{title:"Safe and Sound Program Analysis with Flix",authors:"Magnus Madsen, Ond\u0159ej Lhot\xe1k",venue:"ISSTA '18",url:"https://dl.acm.org/citation.cfm?id=3213847"}),l.a.createElement(R,{title:"Tail Call Elimination and Data Representation for Functional Languages on the Java Virtual Machine",authors:"Magnus Madsen, Ramin Zarifi, Ond\u0159ej Lhot\xe1k",venue:"CC '18",url:"https://dl.acm.org/citation.cfm?id=3179499"}),l.a.createElement(R,{title:"From Datalog to Flix: A Declarative Language for Fixed Points on Lattices",authors:"Magnus Madsen, Ming-Ho Yee, Ond\u0159ej Lhot\xe1k",venue:"PLDI '16",url:"https://dl.acm.org/citation.cfm?id=2908096"})),l.a.createElement("h3",null,"Workshops"),l.a.createElement("ul",null,l.a.createElement(R,{title:"Programming a Dataflow Analysis in Flix",authors:"Magnus Madsen, Ming-Ho Yee, Ond\u0159ej Lhot\xe1k",venue:"TAPAS '16",url:"http://staticanalysis.org/tapas2016/abstracts/TAPAS_2016_MadsenEtAl.pdf"})),l.a.createElement("h3",null,"Theses"),l.a.createElement("ul",null,l.a.createElement(R,{title:"Implementing a Functional Language for Flix",authors:"Ming-Ho Yee",venue:"University of Waterloo",url:"https://uwspace.uwaterloo.ca/bitstream/handle/10012/10856/Yee_Ming-Ho.pdf?sequence=1"})))}}]),t}(n.Component),R=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){return l.a.createElement("li",{className:"mb-3"},l.a.createElement("a",{href:this.props.url},this.props.title)," ",l.a.createElement("b",null,"[",this.props.venue,"]"),l.a.createElement("br",null),this.props.authors)}}]),t}(n.Component),M=L,W=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="Flix | FAQ"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement("h1",null,"Frequently Asked Questions"),l.a.createElement("p",{className:"mb-3"},"A collection of information that did not seem to fit in anywhere else."),l.a.createElement(U,null,l.a.createElement(D,null,"What is on the development road map for Flix?"),l.a.createElement(H,null,l.a.createElement("p",null,"We don't want to over-promise and under-deliver, hence we try to only discuss what has already been implemented. That said, two major features we want to support in Flix are a polymorphic effect system and type classes."),l.a.createElement("p",null,"For smaller features, the GitHub issue tracker gives an idea of the kinds of things we are currently working on."))),l.a.createElement(U,null,l.a.createElement(D,null,"Are you looking for help with the compiler or language design?"),l.a.createElement(H,null,"Yes! We welcome any contributions and we are happy to mentor someone who wants to work on the compiler. We are also open to general feedback and discussion about the language design. Head on over to GitHub / Gitter and reach out to us!")),l.a.createElement(U,null,l.a.createElement(D,null,"Does Flix support integration with Java, Kotlin, Scala etc?"),l.a.createElement(H,null,l.a.createElement("p",null,"No, not at the moment. We have experimental support for calling into Java, but that API is likely to change in the future. We want to get interoperability ",l.a.createElement("i",null,"right"),", but it is a big challenge, since we do not want to sacrifice any of the Flix principles in doing so."),l.a.createElement("p",null,"For example, to support proper interoperability with Java we will need to support ",l.a.createElement("code",null,"null"),", but at the same time we don't want to pollute the Flix language with ",l.a.createElement("code",null,"null")," values. Dealing with such issues is complicated, but something we plan to address long-term."))),l.a.createElement(U,null,l.a.createElement(D,null,"Flix looks quite similar to Scala. How are the two languages related?"),l.a.createElement(H,null,l.a.createElement("p",null,"Flix borrows a lot of syntax from Scala, hence the two languages have a similar feel. We think Scala made many good design choices with respect to syntax, including: (a) the use of short keywords, (b) the ",l.a.createElement("code",null,"x : T")," syntax for type annotations, (c) the ",l.a.createElement("code",null,"List[Int]")," syntax for type parameters, and (d) ",l.a.createElement("code",null,"if"),", ",l.a.createElement("code",null,"match"),", etc. as expressions."),l.a.createElement("p",null,"Other than syntax, the two languages are different: Scala is object-oriented, Flix is not. Scala has sub-typing, Flix does not. The Scala type system is unsound and has imperfect type inference, whereas the Flix type system is both sound and supports type inference."))),l.a.createElement(U,null,l.a.createElement(D,null,"Does Flix have a read-eval-print-loop (REPL)?"),l.a.createElement(H,null,"Flix has a shell that allows expressions to be entered and evaluated on-the-fly. The source code of a program can also be loaded into the shell. However, the shell does not permit the definition of new declarations. The shell can be started with the ",l.a.createElement("code",null,"--interactive")," argument.")),l.a.createElement(U,null,l.a.createElement(D,null,"Does Flix have IDE support? Editor support? Language Server Protocol (LSP) support?"),l.a.createElement(H,null,"No. At the moment we only have keyword based syntax highlighting. We would be happy if someone would pick up a project to add language server protocol (LSP) support. We believe that this is something that will come eventually as the language matures.")),l.a.createElement(U,null,l.a.createElement(D,null,"Does Flix compile to LLVM?"),l.a.createElement(H,null,"No. Flix does not currently have an LLVM backend. It is something we are open to, but it depends on the availability of a garbage collector.")),l.a.createElement(U,null,l.a.createElement(D,null,"Does Flix compile to WebAssembly (WASM)?"),l.a.createElement(H,null,"No. Flix does not currently have a WebAssembly backend. As for LLVM, it is something we are open to, but it depends on the availability of a garbage collector and support for tail call elimination.")),l.a.createElement(U,null,l.a.createElement(D,null,"Is the Flix type system sound?"),l.a.createElement(H,null,"Yes. It is based on Hindley-Milner. Of course the implementation might have bugs, but those are fixable.")),l.a.createElement(U,null,l.a.createElement(D,null,"I want to learn Flix! What should I know about before hand?"),l.a.createElement(H,null,l.a.createElement("p",null,"At the moment, Flix has not yet reached version 1.0. That means you will be an early adopter, so you should expect for the language to evolve and be prepared for the rare compiler bug. (The Flix compiler has 5,500 manually written tests and we take correctness seriously.)"),l.a.createElement("p",null,"To write Flix programs, a solid background in functional programming is useful. That means prior experience with OCaml, Haskell, Scala, or similar programming languages."))),l.a.createElement(U,null,l.a.createElement(D,null,"What is the best way to start learning Flix?"),l.a.createElement(H,null,l.a.createElement("p",null,"We recommend that you start with a small offering to the Great Dreamer, the Sleeper of R'lyeh, Cthulhu. And coffee. Lots of coffee."),l.a.createElement("p",null,"All kidding aside, the examples on the front page and the research literature are probably the best starting points for learning the syntax, semantics, and type system of Flix. Prior experience with functional programming is also useful."),l.a.createElement("p",null,"If you get stuck or need help feel free to reach out to us on Gitter."))),l.a.createElement(U,null,l.a.createElement(D,null,"Is Flix a domain specific language (DSL)?"),l.a.createElement(H,null,l.a.createElement("p",null,"No, Flix is a full-blown functional programming language."),l.a.createElement("p",null,"That said, Flix could be considered a meta-programming language for Datalog."))),l.a.createElement(U,null,l.a.createElement(D,null,"What is the expected runtime performance of Flix programs?"),l.a.createElement(H,null,l.a.createElement("p",null,"Flix runs on the Java Virtual Machine (JVM) hence the performance of Flix is limited by the performance of the JVM. Luckily, the JVM is a mature and performant virtual machine. Flix uses monomorphization which eliminates boxing and in theory can make code execute faster than ordinary Java / Kotlin / Scala code. However, Flix also features tail call elimination and (in the future) delimited continuations, and each of these come with their own performance cost."),l.a.createElement("p",null,"It is our goal to be faster than any interpreted language and within a few factors of equivalent functional Scala code."))),l.a.createElement(U,null,l.a.createElement(D,null,"What is the expected performance of the Flix compiler?"),l.a.createElement(H,null,l.a.createElement("p",null,"To answer this question, it is important to distinguish between ",l.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Latency_(engineering)"},"latency")," and ",l.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Throughput"},"throughput"),"."),l.a.createElement("p",null,"The Flix compiler runs on the JVM hence startup times can be expensive, i.e. the compiler has high latency. However, once the JVM has warmed up the compiler is quite fast, i.e. has high throughput."),l.a.createElement("p",null,"A simple experiment shows that the compiler runs about ",l.a.createElement("code",null,"20.0x")," times faster when warmed up compared to when cold. We estimate that Flix, when warmed up, compiles around ",l.a.createElement("code",null,"20,000")," lines of code per second, which we believe to better than the Scala compiler, but worse than the Java compiler."),l.a.createElement("p",null,"At the moment, the compilation of a Flix program pulls in the entire standard library (a few thousand lines of code) and compiles it along with the program. This behaviour can be avoided, by passing the ",l.a.createElement("code",null,"--Xcore")," flag, but then data types such as ",l.a.createElement("code",null,"List")," will be unavailable. In the future, it is our plan to compile-by-need."))),l.a.createElement(U,null,l.a.createElement(D,null,"Who works on Flix? Is Flix a hobby project?"),l.a.createElement(H,null,"Flix is a research project carried out by faculty and students at Aarhus University and the University of Waterloo.")),l.a.createElement(U,null,l.a.createElement(D,null,'Where does the "Flix" name come from?'),l.a.createElement(H,null,"We do not entirely remember, but we believe it arose out of ",l.a.createElement("span",{className:"text-monospace"},"FIXpoint Language"),".")),l.a.createElement(U,null,l.a.createElement(D,null,"You do not seem to understand parsing / type theory / code generation / computers!"),l.a.createElement(H,null,"We are happy to learn and to revisit design decisions if we come to a greater understanding of the problem at hand. If you think we have overlooked something, we would be happy to talk about it if you post a ticket on GitHub or write to us on Gitter.")),l.a.createElement(U,null,l.a.createElement(D,null,"The language is probably great from a technical point of view, but unless Apple, Google, Mozilla, or Microsoft is on-board it is pointless."),l.a.createElement(H,null,l.a.createElement("p",null,"Yes, no programming language developed outside of those four corporations have ever been successful. See also C, C++, Java, Python, PHP, MatLab, Perl, R, Ruby, Scala, ..."),l.a.createElement("p",null,"That said, if you work for a company and would like to help sponsor Flix, please feel free to reach out to us :)"))),l.a.createElement(U,null,l.a.createElement(D,null,"Does Flix have a network library with streaming support?"),l.a.createElement(H,null,"Not yet, but maybe we could call it net-flix?")),l.a.createElement(U,null,l.a.createElement(D,null,"Wow! Amazing! A language where you can iterate through lists and call functions recursively."),l.a.createElement(H,null,"Magical, isn't it?")),l.a.createElement(U,null,l.a.createElement(D,null,"Great! Yet-another-programming-language\u2122. This is exactly what we need; the gazillion of existing programming languages is not enough."),l.a.createElement(H,null,"Flix aims to offer a combination of language features that are not found in any existing language.")),l.a.createElement(U,null,l.a.createElement(D,null,"The examples all look horrible. The site looks horrible. This needs a lot of work before it gets close to anything I would even consider using."),l.a.createElement(H,null,"I am sorry, what was the question?")))}}]),t}(n.Component),D=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){return l.a.createElement(d.i,null,this.props.children)}}]),t}(n.Component),H=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){return l.a.createElement("div",null,this.props.children)}}]),t}(n.Component),U=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"render",value:function(){return l.a.createElement(d.d,{className:"mb-3"},l.a.createElement(d.e,null,this.props.children))}}]),t}(n.Component),J=W,Y=function(e){function t(){return Object(s.a)(this,t),Object(m.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(h.a)(t,e),Object(c.a)(t,[{key:"componentDidMount",value:function(){document.title="Flix | Documentation"}},{key:"render",value:function(){return l.a.createElement(d.k,null,l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,null,l.a.createElement("h1",null,"Documentation"),l.a.createElement("p",null,"Documentation on Flix is currently a bit sparse. We hope to have better documentation in the future."),l.a.createElement("p",null,"The ",l.a.createElement("a",{href:"http://flix.github.io/programming-flix"},"Programming Flix")," book offers an introduction to Flix for programmers who are already familiar with functional programming."),l.a.createElement("p",null,"The ",l.a.createElement("a",{href:"http://flix.github.io/api/"},"Standard Library")," documentation provides a Javadoc-style description of the Flix API, including the operations available on important types such as ",l.a.createElement("code",null,"Option"),", ",l.a.createElement("code",null,"Result"),", and ",l.a.createElement("code",null,"List"),"."),l.a.createElement("p",null,"The research aspects of Flix are mostly described in the literature."))),l.a.createElement(d.p,{className:"mb-3"},l.a.createElement(d.j,null,l.a.createElement("h3",null,"Programming Language Checklist"),l.a.createElement("p",null,"For completeness (and fun), here is the ",l.a.createElement("a",{href:"http://colinm.org/language_checklist.html"},"programming language check list")," for Flix:"),l.a.createElement("code",null,l.a.createElement("pre",null,'You appear to be advocating a new:\n[x] functional [x] imperative [ ] object-oriented [ ] procedural [ ] stack-based\n[x] "multi-paradigm" [ ] lazy [x] eager [x] statically-typed [ ] dynamically-typed\n[x] pure [x] impure [ ] non-hygienic [ ] visual [ ] beginner-friendly\n[ ] non-programmer-friendly [ ] completely incomprehensible\nprogramming language. Your language will not work. Here is why it will not work.\n\nYou appear to believe that:\n[x] Syntax is what makes programming difficult\n[x] Garbage collection is free [x] Computers have infinite memory\n[ ] Nobody really needs:\n[ ] concurrency [ ] a REPL [ ] debugger support [x] IDE support [ ] I/O\n[x] to interact with code not written in your language\n[ ] The entire world speaks 7-bit ASCII\n[ ] Scaling up to large software projects will be easy\n[x] Convincing programmers to adopt a new language will be easy\n[ ] Convincing programmers to adopt a language-specific IDE will be easy\n[ ] Programmers love writing lots of boilerplate\n[ ] Specifying behaviors as "undefined" means that programmers won\'t rely on them\n[ ] "Spooky action at a distance" makes programming more fun\n\nUnfortunately, your language (has/lacks):\n[h] comprehensible syntax [h] semicolons [ ] significant whitespace [ ] macros\n[ ] implicit type conversion [ ] explicit casting [h] type inference\n[ ] goto [ ] exceptions [h] closures [h] tail recursion [ ] coroutines\n[ ] reflection [ ] subtyping [ ] multiple inheritance [ ] operator overloading\n[h] algebraic datatypes [h] recursive types [h] polymorphic types\n[ ] covariant array typing [ ] monads [ ] dependent types\n[h] infix operators [ ] nested comments [ ] multi-line strings [ ] regexes\n[h] call-by-value [ ] call-by-name [ ] call-by-reference [ ] call-cc\n\nThe following philosophical objections apply:\n[ ] Programmers should not need to understand category theory to write "Hello, World!"\n[ ] Programmers should not develop RSI from writing "Hello, World!"\n[ ] The most significant program written in your language is its own compiler\n[x] The most significant program written in your language isn\'t even its own compiler\n[x] No language spec\n[x] "The implementation is the spec"\n[ ] The implementation is closed-source [ ] covered by patents [ ] not owned by you\n[ ] Your type system is unsound [ ] Your language cannot be unambiguously parsed\n[ ] a proof of same is attached\n[ ] invoking this proof crashes the compiler\n[ ] The name of your language makes it impossible to find on Google\n[ ] Interpreted languages will never be as fast as C\n[x] Compiled languages will never be "extensible"\n[ ] Writing a compiler that understands English is AI-complete\n[ ] Your language relies on an optimization which has never been shown possible\n[ ] There are less than 100 programmers on Earth smart enough to use your language\n[x] Hindley-Milner type inference takes exponential time\n\nYour implementation has the following flaws:\n[x] CPUs do not work that way\n[x] RAM does not work that way\n[ ] VMs do not work that way\n[ ] Compilers do not work that way\n[ ] Compilers cannot work that way\n[x] Shift-reduce conflicts in parsing seem to be resolved using rand()\n[ ] You require the compiler to be present at runtime\n[x] You require the language runtime to be present at compile-time\n[ ] Your compiler errors are completely inscrutable\n[ ] Dangerous behavior is only a warning\n[x] The compiler crashes if you look at it funny\n[ ] The VM crashes if you look at it funny\n[ ] You don\'t seem to understand basic optimization techniques\n[ ] You don\'t seem to understand basic systems programming\n[ ] You don\'t seem to understand pointers\n[ ] You don\'t seem to understand functions\n\nAdditionally, your marketing has the following problems:\n[ ] Unsupported claims of increased productivity\n[ ] Unsupported claims of greater "ease of use"\n[ ] Obviously rigged benchmarks\n[ ] Graphics, simulation, or crypto benchmarks where your code just calls\nhandwritten assembly through your FFI\n[ ] String-processing benchmarks where you just call PCRE\n[ ] Matrix-math benchmarks where you just call BLAS\n[ ] Noone really believes that your language is faster than:\n[ ] assembly [ ] C [ ] FORTRAN [ ] Java [ ] Ruby [ ] Prolog\n[ ] Rejection of orthodox programming-language theory without justification\n[ ] Rejection of orthodox systems programming without justification\n[ ] Rejection of orthodox algorithmic theory without justification\n[ ] Rejection of basic computer science without justification\n\nTaking the wider ecosystem into account, I would like to note that:\n[x] Your complex sample code would be one line in: Haskell, Prolog, Scala, ...\n[ ] We already have an unsafe imperative language\n[ ] We already have a safe imperative OO language\n[x] We already have a safe statically-typed eager functional language\n[ ] You have reinvented Lisp but worse\n[ ] You have reinvented Javascript but worse\n[ ] You have reinvented Java but worse\n[ ] You have reinvented C++ but worse\n[ ] You have reinvented PHP but worse\n[ ] You have reinvented PHP better, but that\'s still no justification\n[ ] You have reinvented Brainfuck but non-ironically\n\nIn conclusion, this is what I think of you:\n[x] You have some interesting ideas, but this won\'t fly.\n[ ] This is a bad language, and you should feel bad for inventing it.\n[ ] Programming in this language is an adequate punishment for inventing it.\n')))))}}]),t}(n.Component),B=a(57),q=a(55),G="wss://flix-evaluator.cs.au.dk/ws",z=function(e){function t(e){var a;Object(s.a)(this,t),(a=Object(m.a)(this,Object(u.a)(t).call(this,e))).runProgram=function(e,t){a.state.connected?(a.state.websocket.onmessage=function(e){console.log("Received reply from: "+G);var a=JSON.parse(e.data);console.log(a),t(a)},a.state.websocket.send(e)):console.log("Not connected yet")},console.log("Connecting to: "+G),a.state={connected:!1,websocket:null};try{a.state.websocket=new window.WebSocket(G),a.state.websocket.onopen=function(e){console.log("Connected to: "+G),a.setState({connected:!0})}}catch(n){console.log("Unable to connect: "+n)}return a}return Object(h.a)(t,e),Object(c.a)(t,[{key:"getHome",value:function(){return l.a.createElement(F,{flix:{connected:this.state.connected,run:this.runProgram.bind(this)}})}},{key:"render",value:function(){var e=this;return l.a.createElement(d.k,{className:"page"},l.a.createElement(d.o,{dark:!0,color:"info",expand:"md",className:"menu shadow-sm mb-4"},l.a.createElement(d.l,{className:"mr-lg-auto",navbar:!0},l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:q.a,to:"/"},"Home")),l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:q.a,to:"/getting-started/"},"Getting Started")),l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:q.a,to:"/principles/"},"Principles")),l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:q.a,to:"/research/"},"Research")),l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:q.a,to:"/documentation/"},"Documentation")),l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:q.a,to:"/faq/"},"FAQ")),l.a.createElement(d.m,{className:"pl-1 pr-1"},l.a.createElement(d.n,{tag:q.a,to:"/contribute/"},"Contribute")))),l.a.createElement(B.a,{path:"/",exact:!0,render:function(){return e.getHome()}}),l.a.createElement(B.a,{path:"/getting-started/",exact:!0,component:O}),l.a.createElement(B.a,{path:"/principles/",exact:!0,component:P}),l.a.createElement(B.a,{path:"/research/",exact:!0,component:M}),l.a.createElement(B.a,{path:"/documentation/",exact:!0,component:Y}),l.a.createElement(B.a,{path:"/faq/",exact:!0,component:J}),l.a.createElement(B.a,{path:"/contribute/",exact:!0,component:T}))}}]),t}(n.Component);o.a.render(l.a.createElement(i.a,null,l.a.createElement(z,null)),document.getElementById("root"))}},[[32,2,1]]]);
//# sourceMappingURL=main.2f46ea2d.chunk.js.map